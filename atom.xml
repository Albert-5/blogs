<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Albert&#39;s Blog</title>
  
  
  <link href="https://albert-5.github.io/blogs/atom.xml" rel="self"/>
  
  <link href="https://albert-5.github.io/blogs/"/>
  <updated>2022-04-27T10:07:32.726Z</updated>
  <id>https://albert-5.github.io/blogs/</id>
  
  <author>
    <name>Albert</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>manim使用手册</title>
    <link href="https://albert-5.github.io/blogs/ba616724/"/>
    <id>https://albert-5.github.io/blogs/ba616724/</id>
    <published>2022-04-27T09:57:52.000Z</published>
    <updated>2022-04-27T10:07:32.726Z</updated>
    
    <content type="html"><![CDATA[<h2 id="manim-的基础操作"><a href="#manim-的基础操作" class="headerlink" title="manim 的基础操作"></a>manim 的基础操作</h2><p>当我们完成了manim的安装后，我们使用 manimgl example_scenes.py 命令来查看manim的安装，当执行此命令后，系统会提示需要选择哪个场景来运行，毕竟manim是使用场景来区分每个代码类，当我们选择其对应的场景后，若manim安装完全正确，此时屏幕上会弹出一个运行窗口，实时渲染代码生成的视频，当然你也可以从cmd窗口中看到当前执行的场景特效，具体执行代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">manimgl example_scenes.py</span><br><span class="line">Warning: Using the default configuration file, which you can modify in e:\学习\python\python_manim\lib\site-packages\manimlib\default_config.yml</span><br><span class="line">If you want to create a local configuration file, you can create a file named custom_config.yml, or run manimgl --config</span><br><span class="line">01: AnimatingMethods</span><br><span class="line">02: ControlsExample</span><br><span class="line">03: CoordinateSystemExample</span><br><span class="line">04: GraphExample</span><br><span class="line">05: InteractiveDevelopment</span><br><span class="line">06: OpeningManimExample</span><br><span class="line">07: SurfaceExample</span><br><span class="line">08: TexTransformExample</span><br><span class="line">09: TextExample</span><br><span class="line">10: UpdatersExample</span><br><span class="line">That module has multiple scenes, which ones would you like to render?</span><br><span class="line">Scene Name or Number: 06</span><br><span class="line">Animation 6: FadeOutNumberPlane, etc.:   0%|   | 0/45 [00:00&lt;?, ?it/s] Warning: The value of the pressed key is too large.</span><br><span class="line">Animation 6: FadeOutNumberPlane, etc.:  69%|#############################6             | 31/45 [00:01&lt;00:00, 22.30it/s]</span><br></pre></td></tr></table></figure><p>在执行代码时，我们可以通过如下按键查看不同视角的代码视频</p><ul><li>滚动鼠标中键可上下移动屏幕。</li><li>在滚动鼠标中键的同时按住Z键，可缩放屏幕。</li><li>按住s键并移动鼠标，可平移屏幕。</li><li>按住d键并移动鼠标，可改变三维视角。</li><li>最后，可以通过按 q键，关闭窗口并退出程序。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.loli.net/2022/04/27/GHV8qcitSXvD5MZ.png" alt="SurfaceExample.png" title>                </div>                <div class="image-caption">SurfaceExample.png</div>            </figure><p>manim操作</p><p><strong>manim 的特殊CLI 标签</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.loli.net/2022/04/27/FBoV9iRqrWaCxHt.png" alt="GraphExample.png" title>                </div>                <div class="image-caption">GraphExample.png</div>            </figure><p>manim</p><p>通过简单的代码指令manimgl example_scenes.py GraphExample，便可以运行example_scenes.py 代码下的GraphExample场景，此时我们只能通过程序打开的窗口查看实际运行的效果，但是我们若想另存为视频或者图片，该如何操作那？</p><p>manim为我们提供了很多有用的flag标签，我们可以在执行以上代码指令后面添加我们 需要的CLI标签，以便能够达到我们想要的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">flag           缩写              功能</span><br><span class="line">--help      -h           显示帮助信息并退出</span><br><span class="line"> --write_file  -w 将场景渲染为电影文件</span><br><span class="line">--skip_animations    -s   跳到最后一帧</span><br><span class="line">--low_quality   -l     以低质量渲染（为了更快的渲染）</span><br><span class="line">--medium_quality   -m 以中等质量渲染</span><br><span class="line"> --hd                          以 1080p 质量渲染</span><br><span class="line">--uhd                        以 4k 质量渲染</span><br><span class="line">--full_scree  -f         全屏显示窗口</span><br><span class="line">--save_pngs   -g     将每一帧保存为 png</span><br><span class="line">--save_as_gif  -i      将视频保存为 gif</span><br><span class="line">--transparent -t   渲染为带有 Alpha 通道的电影文件</span><br><span class="line">--quiet           -q   消去视频声音</span><br><span class="line">--write_all    -a    从文件中写入所有场景</span><br><span class="line">--open    -o       完成后自动打开保存的文件</span><br><span class="line">--finder                在finder中显示输出文件</span><br><span class="line">--config                自动配置指南</span><br><span class="line">--file_name FILE_NAME        电影或图像文件的名称</span><br><span class="line">--start_at_animation_number      不是从第一个动画开始渲染，而是从另一个动画开始渲染</span><br><span class="line">START_AT_ANIMATION_NUMBER -n   由其索引指定。如果您传入两个逗号分隔值，例如“3,6”，它将在第二个值处结束渲染。</span><br><span class="line">--resolution RESOLUTION     -r  分辨率，以“WxH”传递，例如“1920x1080”</span><br><span class="line">--frame_rate FRAME_RATE      帧率，整数形式</span><br><span class="line">  --color COLOR    -c  背景颜色</span><br><span class="line">--leave_progress_bars    在终端中显示进度条</span><br><span class="line">--video_dir VIDEO_DIR   写视频的目录</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">flag</th><th style="text-align:center">缩写</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">–help</td><td style="text-align:center">-h</td><td style="text-align:center">显示帮助信息并退出</td></tr><tr><td style="text-align:center">–write</td><td style="text-align:center">-w</td><td style="text-align:center">将场景渲染为电影文件</td></tr><tr><td style="text-align:center">–skip_animations</td><td style="text-align:center">-s</td><td style="text-align:center">调到最后一帧</td></tr><tr><td style="text-align:center">–low_quality</td><td style="text-align:center">-l</td><td style="text-align:center">以低质量渲染</td></tr><tr><td style="text-align:center">–medium_quality</td><td style="text-align:center">-m</td><td style="text-align:center">以中等质量渲染</td></tr><tr><td style="text-align:center">–hd</td><td style="text-align:center"></td><td style="text-align:center">以1080p质量渲染</td></tr><tr><td style="text-align:center">–uhd</td><td style="text-align:center"></td><td style="text-align:center">4k质量渲染</td></tr><tr><td style="text-align:center">–full_screen</td><td style="text-align:center">-f</td><td style="text-align:center">全屏显示窗口</td></tr><tr><td style="text-align:center">–save_pngs</td><td style="text-align:center">-g</td><td style="text-align:center">将每一帧保存为png</td></tr><tr><td style="text-align:center">–save_as_gif</td><td style="text-align:center">-i</td><td style="text-align:center">将视频保存为gif</td></tr><tr><td style="text-align:center">–transparent</td><td style="text-align:center">-t</td><td style="text-align:center">渲染为带有Alpha通道的电影文件</td></tr><tr><td style="text-align:center">–quiet</td><td style="text-align:center">-q</td><td style="text-align:center">消去视频声音</td></tr><tr><td style="text-align:center">–write_all</td><td style="text-align:center">-a</td><td style="text-align:center">从文件中写入所有场景</td></tr><tr><td style="text-align:center">–open</td><td style="text-align:center">-o</td><td style="text-align:center">完成后自动打开保存的文件</td></tr><tr><td style="text-align:center">–finder</td><td style="text-align:center"></td><td style="text-align:center">在finder中显示输出文件</td></tr><tr><td style="text-align:center">–config</td><td style="text-align:center"></td><td style="text-align:center">自动配置指南</td></tr><tr><td style="text-align:center">–file_name FILE_NAME</td><td style="text-align:center"></td><td style="text-align:center">电影或图像文件的名称</td></tr><tr><td style="text-align:center">–start_at_animation_number</td><td style="text-align:center"></td><td style="text-align:center">不是从第一个动画开始渲染，而是从另一个动画开始渲染</td></tr><tr><td style="text-align:center">–resolution RESOLUTION</td><td style="text-align:center">-r</td><td style="text-align:center">分辨率，以“W×H”格式，如，1920×1080</td></tr><tr><td style="text-align:center">–color COLOR</td><td style="text-align:center"></td><td style="text-align:center">背景颜色</td></tr><tr><td style="text-align:center">–leave_progress_bars</td><td style="text-align:center"></td><td style="text-align:center">在终端中显示进度条</td></tr><tr><td style="text-align:center">–video_dir VIDEO_DIR</td><td style="text-align:center"></td><td style="text-align:center">写视频的目录</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>flag标签</p><p><strong>manim 的custom_config配置文件</strong></p><p>当我们安装完成manim后，manim引擎会自动建立一个默认的配置文件default_config.yml，此文件配置了一些我们常用的配置，当然若自己想设计一个属于自己的配置文件，可以在脚本同目录下建立一个custom_config.yml配置文件，当代码运行时，会首先选择custom_config.yml配置进行系统的配置运行，否则使用默认配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">manim/</span><br><span class="line">├── manimlib/</span><br><span class="line">│   ├── animation/</span><br><span class="line">│   ├── ...</span><br><span class="line">│   ├── default_config.yml</span><br><span class="line">│   └── window.py</span><br><span class="line">├── project/</span><br><span class="line">│   ├── code.py</span><br><span class="line">│   └── custom_config.yml</span><br><span class="line">└── custom_config.yml</span><br></pre></td></tr></table></figure><p>配置文件中定义了不同的使用功能，主要代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">directories:</span><br><span class="line">  mirror_module_path: False</span><br><span class="line">  output: &quot;./video&quot;</span><br><span class="line">  raster_images: &quot;&quot;</span><br><span class="line">  vector_images: &quot;&quot;</span><br><span class="line">  sounds: &quot;&quot;</span><br><span class="line">  temporary_storage: &quot;&quot;</span><br><span class="line">tex:</span><br><span class="line">  executable: &quot;latex&quot;</span><br><span class="line">  template_file: &quot;tex_template.tex&quot; </span><br><span class="line">  intermediate_filetype: &quot;dvi&quot;</span><br><span class="line">  text_to_replace: &quot;[tex_expression]&quot;</span><br><span class="line">universal_import_line: &quot;from manimlib import *&quot;</span><br><span class="line">style:</span><br><span class="line">  font: &quot;Consolas&quot;</span><br><span class="line">  background_color: &quot;#333333&quot;</span><br><span class="line">window_position: UR</span><br><span class="line">window_monitor: 0</span><br><span class="line">break_into_partial_movies: False</span><br><span class="line">camera_qualities:</span><br><span class="line">  low:</span><br><span class="line">    resolution: &quot;854x480&quot;</span><br><span class="line">    frame_rate: 30</span><br><span class="line">  medium:</span><br><span class="line">    resolution: &quot;1280x720&quot;</span><br><span class="line">    frame_rate: 60</span><br><span class="line">  high:</span><br><span class="line">    resolution: &quot;1920x1080&quot;</span><br><span class="line">    frame_rate: 60</span><br><span class="line">  ultra_high:</span><br><span class="line">    resolution: &quot;3840x2160&quot;</span><br><span class="line">    frame_rate: 80</span><br><span class="line">  default_quality: &quot;low&quot;</span><br></pre></td></tr></table></figure><p>manim</p><ul><li>mirror_module_path(True或False) 是否在output路径下创建一个以运行文件名称命名的文件夹，并将输出(images/ 或videos/)保存在其中。</li><li>output输出文件路径，视频将保存在其videos/下的文件夹中，图片将保存在其images/下的文件夹中。例如，如果你设置output为”/…/manim/output”和 mirror_module_path为False，那么你Scene1在代码文件中导出并保存了最后一帧，那么最终的目录结构将是这样的：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">manim/</span><br><span class="line">    ├── manimlib/</span><br><span class="line">    │   ├── animation/</span><br><span class="line">    │   ├── ...</span><br><span class="line">    │   ├── default_config.yml</span><br><span class="line">    │   └── window.py</span><br><span class="line">    ├── output/</span><br><span class="line">    │   ├── images</span><br><span class="line">    │   │   └── Scene1.png</span><br><span class="line">    │   └── videos</span><br><span class="line">    │       └── Scene1.mp4</span><br><span class="line">    ├── code.py</span><br><span class="line">    └── custom_config.yml</span><br></pre></td></tr></table></figure><p>但是如果你设置mirror_module_path为True，目录结构将是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">manim/</span><br><span class="line">    ├── manimlib/</span><br><span class="line">    │   ├── animation/</span><br><span class="line">    │   ├── ...</span><br><span class="line">    │   ├── default_config.yml</span><br><span class="line">    │   └── window.py</span><br><span class="line">    ├── output/</span><br><span class="line">    │   └── code/</span><br><span class="line">    │       ├── images</span><br><span class="line">    │       │   └── Scene1.png</span><br><span class="line">    │       └── videos</span><br><span class="line">    │           └── Scene1.mp4</span><br><span class="line">    ├── code.py</span><br><span class="line">    └── custom_config.yml</span><br></pre></td></tr></table></figure><ul><li>raster_images用于存储代码中使用的光栅图像的目录（包括 .jpg、.png和.gif），将由ImageMobject读取.</li><li>vector_images用于存储代码中使用的矢量图的目录（包括 .svg和.xdv），将由SVGMobject读取.</li><li>sounds用于存储要使用的声音文件的目录Scene.add_sound()（包括.wav和.mp3）。</li><li>temporary_storage存放临时生成的缓存文件的目录，包括 Tex缓存、Text缓存和对象点的存储。</li></ul><p>manim实例</p><h2 id="tex"><a href="#tex" class="headerlink" title="tex"></a>tex</h2><ul><li>executable用于编译 LaTeX 的可执行程序（latex）xelatex -no-pdf</li><li>template_file使用的 LaTeX 模板，在 manimlib/tex_templates</li><li>intermediate_filetype编译后生成的中间向量文件的类型</li><li>text_to_replace模板中要替换的文本</li></ul><p><strong>universal_import_line</strong></p><p>导入直接进入交互模式时需要执行的行。</p><p><strong>style</strong></p><ul><li>font文本的默认字体</li><li>background_color默认背景色</li></ul><p><strong>window_position</strong></p><p>播放窗口在显示器上的相对位置（两个字符，第一个字符表示上（U）/中（O）/下（D），第二个字符表示左（L）/中（O）/右（R） ))。</p><p><strong>break_into_partial_movies</strong></p><p>如果设置为True，那么很多小文件将对应于每个写入Scene.play和Scene.wait调用，然后这些文件将被合并，以形成完整的场景。</p><p><strong>camera_qualities：输出视频的质量</strong></p><ul><li>low低质量（默认为 480p，15帧）</li><li>medium中等质量（默认为 720p，30帧）</li><li>high高质量（默认为 1080p，30帧）</li><li>ultra_high超高画质（默认为 4K ，60帧）</li><li>default_quality默认质量（以上四种之一）</li></ul><p>当然，我们在运行manim的时候主要是一个预览的功能，这里default_quality建议选择low，这样会提高代码运行效率，最后我们输出视频时可以加flag标签来控制视频的输入质量，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">manimgl example_scenes.py GraphExample -w --uhd</span><br><span class="line">便是保存4k高清画质的视频文件</span><br></pre></td></tr></table></figure><p>本期我们分享了manim的基础操作与配置，后期我们将分享manim动画的基础知识，打造属于自己的manim动画效果</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.loli.net/2022/04/27/RGosPMrlmqiL1Fc.jpg" alt="manim.jpg" title>                </div>                <div class="image-caption">manim.jpg</div>            </figure><p>官方社区 <a href="https://docs.manim.community/" target="_blank" rel="noopener">https://docs.manim.community/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;manim-的基础操作&quot;&gt;&lt;a href=&quot;#manim-的基础操作&quot; class=&quot;headerlink&quot; title=&quot;manim 的基础操作&quot;&gt;&lt;/a&gt;manim 的基础操作&lt;/h2&gt;&lt;p&gt;当我们完成了manim的安装后，我们使用 manimgl examp</summary>
      
    
    
    
    <category term="manim" scheme="https://albert-5.github.io/blogs/categories/manim/"/>
    
    
    <category term="manim" scheme="https://albert-5.github.io/blogs/tags/manim/"/>
    
  </entry>
  
  <entry>
    <title>hello_world</title>
    <link href="https://albert-5.github.io/blogs/f73eae91/"/>
    <id>https://albert-5.github.io/blogs/f73eae91/</id>
    <published>2022-03-09T10:54:11.000Z</published>
    <updated>2022-03-09T10:54:29.248Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://albert-5.github.io/blogs/4a17b156/"/>
    <id>https://albert-5.github.io/blogs/4a17b156/</id>
    <published>2022-03-09T10:47:07.110Z</published>
    <updated>2021-09-16T13:30:22.517Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.</summary>
      
    
    
    
    <category term="你好，世界" scheme="https://albert-5.github.io/blogs/categories/你好，世界/"/>
    
    
    <category term="hello_world" scheme="https://albert-5.github.io/blogs/tags/hello-world/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习笔记六</title>
    <link href="https://albert-5.github.io/blogs/fc88e170/"/>
    <id>https://albert-5.github.io/blogs/fc88e170/</id>
    <published>2022-02-13T02:22:46.000Z</published>
    <updated>2022-02-14T07:01:00.456Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux学习笔记六"><a href="#Linux学习笔记六" class="headerlink" title="Linux学习笔记六"></a>Linux学习笔记六</h1><h2 id="Linux任务计划crontab"><a href="#Linux任务计划crontab" class="headerlink" title="Linux任务计划crontab"></a>Linux任务计划crontab</h2><p>周期性的清理<code>/tmp</code>、周期性的去备份一次数据库、周期性的分析日志等，因此需要利用Linux系统的计划工具–crontab（用于设置周期性被执行的命令）。</p><p>crontab命令从输入设备读取指令，并将其存放于crontab文件中，以供之后读取和执行。通常情况下，crontab存储的指令被守护进程激活，crond为其守护进程，crond常常在后台运行，每一分钟会检查一次是否由预定的作业需要执行。</p><p>crontab指令格式：</p><blockquote><p># Example of job definition: </p><p>#.—————- minute (0 - 59) </p><p>#|  .————- hour (0 - 23) </p><p>#|  |  .———- day of month (1 - 31) </p><p>#|  |  |  .——- month (1 - 12) OR jan,feb,mar,apr … </p><p>#|  |  |  |  .—- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</p><p>#|  |  |  |  | # <em>  </em>  <em>  </em>  * user-name command to be executed</p></blockquote><p><strong>crontab的使用</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure><p>以上命令来添加一个计划任务。</p><p>然后通过以下命令来查看添加了哪些内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -l</span><br></pre></td></tr></table></figure><p>确保<code>cron</code>是否成功在后台启动的方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep cron</span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line">pgrep cron</span><br></pre></td></tr></table></figure><p>在不需要这个任务时可以使用以下命令来删除一个任务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -r</span><br></pre></td></tr></table></figure><h2 id="命令执行顺序控制和管道"><a href="#命令执行顺序控制和管道" class="headerlink" title="命令执行顺序控制和管道"></a>命令执行顺序控制和管道</h2><h3 id="顺序执行多条命令"><a href="#顺序执行多条命令" class="headerlink" title="顺序执行多条命令"></a>顺序执行多条命令</h3><p><strong>安装软件</strong></p><p>使用<code>apt-get</code>安装软件，然后安装完成后立即运行安装的软件或命令工具，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install some-tool</span><br><span class="line">some-tool</span><br></pre></td></tr></table></figure><p>但要是一次性输入完，让它自己去依次执行各个命令，简单的顺序执行可以使用<code>;</code>来完成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update;sudo apt-get install some-tool;some-tool</span><br></pre></td></tr></table></figure><h3 id="有选择的执行命令"><a href="#有选择的执行命令" class="headerlink" title="有选择的执行命令"></a>有选择的执行命令</h3><p>即上一条命令执行成功才继续下一条，或者不成功又该做出其它处理。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which cowsay&gt;/dev/null &amp;&amp; cowsay -f head-in ohch~</span><br></pre></td></tr></table></figure><p>上面的<code>&amp;&amp;</code>就是用来实现选择性执行的，它表示如果前面的命令执行结果（不是表示终端输出的内容而是表示命令执行状态的结果）返回0则执行后面的，否则不执行，可以从<code>$?</code>环境变量获取上一次命令的返回结果。</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道是一种通信机制，通常用于进程间的通信（也可以通过socket进行网络通信），它表现出来的形式就是将前面每一个进程的输出（stdout）直接作为下一个进程的输入（stdin）。</p><p>其中管道又分为<strong>匿名管道</strong>和<strong>具名管道</strong>。匿名管道在使用时通常是用分隔符<code>|</code>表示。</p><p>查看<code>/etc</code>目录下有哪些文件和目录，使用<code>ls</code>来查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al /etc</span><br></pre></td></tr></table></figure><p>可是内容太多，屏幕并不能完全显示，这时就需要使用滚动条或者快捷键滚动窗口来查看，但也可以使用管道：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al /etc | less</span><br></pre></td></tr></table></figure><p>通过管道将前一个命令(<code>ls</code>)的输出作为下一个命令(<code>less</code>)的输入，然后就可以一行一行的看。</p><h3 id="cut命令打印输出文件"><a href="#cut命令打印输出文件" class="headerlink" title="cut命令打印输出文件"></a><code>cut</code>命令打印输出文件</h3><p>打印 <code>/etc/passwd</code> 文件中以 <code>:</code> 为分隔符的第 1 个字段和第 6 个字段分别表示用户名和其家目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut /etc/passwd -d ':' -f 1,6</span><br></pre></td></tr></table></figure><p>打印 <code>/etc/passwd</code> 文件中每一行的前 N 个字符：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前五个（包含第五个）</span></span><br><span class="line">cut /etc/passwd -c -5</span><br><span class="line"><span class="comment"># 前五个之后的（包含第五个）</span></span><br><span class="line">cut /etc/passwd -c 5-</span><br><span class="line"><span class="comment"># 第五个</span></span><br><span class="line">cut /etc/passwd -c 5</span><br><span class="line"><span class="comment"># 2 到 5 之间的（包含第五个）</span></span><br><span class="line">cut /etc/passwd -c 2-5</span><br></pre></td></tr></table></figure><h3 id="grep命令–查找"><a href="#grep命令–查找" class="headerlink" title="grep命令–查找"></a>grep命令–查找</h3><p>一般形式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [命令选项]... 用于匹配的表达式 [文件]</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -rnI "shiyanlou" ~</span><br></pre></td></tr></table></figure><p><code>-r</code>参数表示递归搜索子目录中的文件，<code>-n</code>表示打印匹配项行号，<code>-I</code>表示忽略二进制文件。</p><h3 id="wc命令"><a href="#wc命令" class="headerlink" title="wc命令"></a>wc命令</h3><p>该命令用于统计并输出一个文件中的行、单词和字节的数目。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 行数</span></span><br><span class="line">wc -l /etc/passwd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 单词数</span></span><br><span class="line">wc -w /etc/passwd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 字节数</span></span><br><span class="line">wc -c /etc/passwd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 字符数</span></span><br><span class="line">wc -m /etc/passwd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 最长行字节数</span></span><br><span class="line">wc -L /etc/passwd</span><br></pre></td></tr></table></figure><h3 id="sort排序"><a href="#sort排序" class="headerlink" title="sort排序"></a>sort排序</h3><p>该功能是将输入按照一定方式排序，然后再输出，它支持的排序有按字典排序、数字排序、按月份排序、随机排序、反转排序和指定特定字段进行排序。</p><p>默认为字典排序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd | sort</span><br></pre></td></tr></table></figure><p>反转排序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd | sort -r</span><br></pre></td></tr></table></figure><p>按特定字段排序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd | sort -t<span class="string">':'</span> -k 3</span><br></pre></td></tr></table></figure><p><code>-t</code>参数用于指定字段的分隔符；<code>-k</code>字段号用于指定对哪一个字段进行排序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux学习笔记六&quot;&gt;&lt;a href=&quot;#Linux学习笔记六&quot; class=&quot;headerlink&quot; title=&quot;Linux学习笔记六&quot;&gt;&lt;/a&gt;Linux学习笔记六&lt;/h1&gt;&lt;h2 id=&quot;Linux任务计划crontab&quot;&gt;&lt;a href=&quot;#Linux</summary>
      
    
    
    
    <category term="Linux学习笔记" scheme="https://albert-5.github.io/blogs/categories/Linux学习笔记/"/>
    
    
    <category term="学习笔记" scheme="https://albert-5.github.io/blogs/tags/学习笔记/"/>
    
    <category term="Linux" scheme="https://albert-5.github.io/blogs/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习笔记五</title>
    <link href="https://albert-5.github.io/blogs/fa912973/"/>
    <id>https://albert-5.github.io/blogs/fa912973/</id>
    <published>2022-02-13T02:21:27.000Z</published>
    <updated>2022-02-14T07:01:00.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux学习笔记五"><a href="#Linux学习笔记五" class="headerlink" title="Linux学习笔记五"></a>Linux学习笔记五</h1><h2 id="文件系统操作与磁盘管理"><a href="#文件系统操作与磁盘管理" class="headerlink" title="文件系统操作与磁盘管理"></a>文件系统操作与磁盘管理</h2><h3 id="查看磁盘和目录的容量"><a href="#查看磁盘和目录的容量" class="headerlink" title="查看磁盘和目录的容量"></a>查看磁盘和目录的容量</h3><p><strong>使用<code>df</code>命令查看磁盘的容量</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df</span><br><span class="line">df -h  便于人们阅读</span><br></pre></td></tr></table></figure><p>在物理主机中，物理主机上的 <code>/dev/sda2</code> 是对应着主机硬盘的分区，后面的数字表示分区号，数字前面的字母 a 表示第几块硬盘（也可能是可移动磁盘），你如果主机上有多块硬盘则可能还会出现 <code>/dev/sdb</code>，<code>/dev/sdc</code> 这些磁盘设备都会在 <code>/dev</code> 目录下以文件的存在形式。</p><p><strong>使用<code>du</code>命令查看目录的容量</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">du</span><br><span class="line">du -h</span><br><span class="line"><span class="meta">#</span><span class="bash"> -d参数查看目录的深度</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 只查看一级目录的信息</span></span><br><span class="line">du -h -d 0 ~</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看二级目录</span></span><br><span class="line">du -h -d 1 ~</span><br><span class="line"><span class="meta">#</span><span class="bash"> 同 --all 显示目录中所有文件的大小</span></span><br><span class="line">du -a</span><br><span class="line"><span class="meta">#</span><span class="bash"> 同 --summarize 仅显示总和，只列出最后加总的和</span></span><br><span class="line">du -s</span><br></pre></td></tr></table></figure><h3 id="创建虚拟磁盘"><a href="#创建虚拟磁盘" class="headerlink" title="创建虚拟磁盘"></a>创建虚拟磁盘</h3><p><code>dd</code>命令：用于转换和复制文件，Linux思想：<strong>一切皆文件</strong>，而且硬件的设备驱动（如硬盘）和特殊设备文件（如<code>/dev/zero</code>和<code>/dev/random</code>）都像普通文件一样，只是在各自的驱动程序中实现了对应的功能，这样<code>dd</code>命令也可以用在备份硬件的引导扇区，获取一定数量的随机数据或空数据等。命令格式为<code>选项=值</code>，默认情况下从标准输入中读取，并写入到标准输出中，但可以用选项<code>if(input file)</code>和<code>of(output file)</code>改变。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 输出到文件</span></span><br><span class="line">dd of=test bs=10 count=1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出到标准输出</span></span><br><span class="line">dd if=/dev/stdin of=/dev/stdout bs=10 count=1</span><br></pre></td></tr></table></figure><p>上述中，<code>bs</code>表示block size，用于指定块大小，缺省单位为Bytes，也可以指定为<code>K M G</code>；<code>count</code>用于指定块数量</p><p><strong>使用<code>dd</code>命令创建虚拟镜像文件</strong></p><p>从<code>/dev/zero</code>设备创建一个容量为256M的空文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero of=virtual.img bs=1M count=256</span><br><span class="line">du -h virtural.img</span><br></pre></td></tr></table></figure><p>然后将此文件格式化（写入文件系统）。</p><p><strong>使用<code>mkfs</code>命令格式化磁盘</strong></p><p>将虚拟磁盘镜像格式化为<code>ext4</code>文件系统。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkfs.ext4 virtual.img</span><br></pre></td></tr></table></figure><p><strong>使用<code>mount</code>命令挂载磁盘到目录树</strong></p><p>用户在Linux/UNIX的机器上打开一个文件之前，包含该文件的文件系统必须先进行挂载的操作，此时用户要对该文件系统执行<code>mount</code>指令来进行挂载。该指令通常是使用在USB或其他可移除存储设备上，而根目录则需要始终保持挂载的状态</p><p>查看下主机已经挂载的文件系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount</span><br></pre></td></tr></table></figure><p>其中命令格式为：<code>mount [option][source][directory]</code></p><p><strong>挂载创建的虚拟硬盘镜像到指定目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount -o loop -t ext4 virtual.img /指定目录</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以只读方式挂载</span></span><br><span class="line">mount -o loop --ro virtual.img /指定目录</span><br></pre></td></tr></table></figure><p><strong>使用<code>umount</code>命令卸载已经挂载的磁盘</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo umount /目录</span><br></pre></td></tr></table></figure><p><strong>使用<code>fdisk</code>为磁盘分区</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看硬盘分区表信息</span></span><br><span class="line">sudo fdisk -l</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入磁盘分区模式</span></span><br><span class="line">sudo fdisk virtual.img</span><br></pre></td></tr></table></figure><h3 id="轻松一下"><a href="#轻松一下" class="headerlink" title="轻松一下"></a>轻松一下</h3><p><code>cowsay</code>在终端里以一种动物说话的方式打印输出一段话</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install -y cowsay</span><br><span class="line">cowsay hello world # 默认是牛</span><br><span class="line"><span class="meta">#</span><span class="bash"> 加上‘-l’参数打印所有支持的动物种类</span></span><br><span class="line">cowsay -l</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用<span class="string">'-f'</span>参数选择动物种类</span></span><br><span class="line">cowsay -f elephant hello world</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装fortune-zh</span></span><br><span class="line">sudo apt-get fortune-zh</span><br><span class="line">/user/games/fortune | cowsay -f da</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux学习笔记五&quot;&gt;&lt;a href=&quot;#Linux学习笔记五&quot; class=&quot;headerlink&quot; title=&quot;Linux学习笔记五&quot;&gt;&lt;/a&gt;Linux学习笔记五&lt;/h1&gt;&lt;h2 id=&quot;文件系统操作与磁盘管理&quot;&gt;&lt;a href=&quot;#文件系统操作与磁盘管</summary>
      
    
    
    
    <category term="Linux学习笔记" scheme="https://albert-5.github.io/blogs/categories/Linux学习笔记/"/>
    
    
    <category term="学习笔记" scheme="https://albert-5.github.io/blogs/tags/学习笔记/"/>
    
    <category term="Linux" scheme="https://albert-5.github.io/blogs/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习笔记四</title>
    <link href="https://albert-5.github.io/blogs/e7734b36/"/>
    <id>https://albert-5.github.io/blogs/e7734b36/</id>
    <published>2022-02-07T03:19:49.000Z</published>
    <updated>2022-02-07T03:26:42.910Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux学习笔记四"><a href="#Linux学习笔记四" class="headerlink" title="Linux学习笔记四"></a>Linux学习笔记四</h1><h2 id="文件打包"><a href="#文件打包" class="headerlink" title="文件打包"></a>文件打包</h2><p>常见的文件压缩包文件格式，windows上常见的有<code>*.zip</code>、<code>*.7z</code>。但Linux上要有更多，如下：</p><table><thead><tr><th>文件后缀名</th><th>说明</th></tr></thead><tbody><tr><td><code>*.zip</code></td><td>zip 程序打包压缩的文件</td></tr><tr><td><code>*.rar</code></td><td>rar 程序压缩的文件</td></tr><tr><td><code>*.7z</code></td><td>7zip 程序压缩的文件</td></tr><tr><td><code>*.tar</code></td><td>tar 程序打包，未压缩的文件</td></tr><tr><td><code>*.gz</code></td><td>gzip 程序（GNU zip）压缩的文件</td></tr><tr><td><code>*.xz</code></td><td>xz 程序压缩的文件</td></tr><tr><td><code>*.bz2</code></td><td>bzip2 程序压缩的文件</td></tr><tr><td><code>*.tar.gz</code></td><td>tar 打包，gzip 程序压缩的文件</td></tr><tr><td><code>*.tar.xz</code></td><td>tar 打包，xz 程序压缩的文件</td></tr><tr><td><code>*tar.bz2</code></td><td>tar 打包，bzip2 程序压缩的文件</td></tr><tr><td><code>*.tar.7z</code></td><td>tar 打包，7z 程序压缩的文件</td></tr></tbody></table><p><strong>使用<code>zip</code>打包文件夹</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd 目录</span><br><span class="line">zip -p -r -o fiel.zip 路径</span><br><span class="line">du -h file.zip</span><br><span class="line">file file.zip</span><br></pre></td></tr></table></figure><p>其中，<code>-r</code>参数表示递归打包包含子目录的全部内容，<code>-q</code>参数表示为安静模式，即不向屏幕输出信息，<code>-o</code>表示输出文件，需在其后紧跟打包输出文件名。后面使用<code>du</code>命令查看打包后文件的大小。</p><ul><li>设置压缩级别为9和1（9最大，1最小），重新打包。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zip -r -9 -q -o filename.zip</span><br><span class="line">zip -r -1 -q -o filename.zip</span><br></pre></td></tr></table></figure><p>1表示最快压缩但体积大，9表示体积最小但耗时最久。</p><p>在使用<code>du</code>命令分别查看默认压缩级别、最低、最高压缩级别以及未压缩的文件的大小。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -h -d 0 *.zip ~ | sort</span><br></pre></td></tr></table></figure><p><code>注</code> <code>-h</code>全称–human-reachable，易人们读；<code>-d</code>全称为–max-depth</p><p><strong>创建加密zip包</strong></p><p>使用<code>-e</code>参数可以创建加密压缩包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r -e -o file.zip 待压缩文件目录</span><br></pre></td></tr></table></figure><p>但如果想让在Linux创建的zip压缩包文件在Windows上解压后没有任何问题，需要使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r -l -o file.zip 待压缩文件目录</span><br></pre></td></tr></table></figure><p><strong>使用<code>unzip</code>解压到当前目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip file.zip</span><br></pre></td></tr></table></figure><p>使用安静模式，将文件解压到指定目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -q file.zip -d ziptest</span><br></pre></td></tr></table></figure><p>但如果只想查看压缩包的内容可以使用<code>-l</code>参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -l file.zip</span><br></pre></td></tr></table></figure><h2 id="文件压缩"><a href="#文件压缩" class="headerlink" title="文件压缩"></a>文件压缩</h2><h3 id="文件打包工具tar"><a href="#文件打包工具tar" class="headerlink" title="文件打包工具tar"></a>文件打包工具<code>tar</code></h3><p>创建一个<code>tar</code>包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 目录</span><br><span class="line">tar -P -cf file.tar 文件路径</span><br></pre></td></tr></table></figure><p>其中，<code>-p</code>保留绝对路径符，<code>-c</code>表示创建一个tar包文件，<code>-f</code>用于指定创建的文件名，文件名必须紧跟在<code>-f</code>之后。</p><ul><li><p>解包一个文件（<code>-x</code>参数）到指定路径的已存在目录（<code>-C</code>参数）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir tardir</span><br><span class="line">tar -xf file.tar -C tardir</span><br></pre></td></tr></table></figure></li><li><p>只查看不解包文件<code>-t</code>参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -tf file.tar</span><br></pre></td></tr></table></figure></li><li><p>保留文件属性和跟随链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cpf etc.tar etc</span><br></pre></td></tr></table></figure></li></ul><p><strong>冬季火炉</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libaa-bin</span><br><span class="line">aafire</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux学习笔记四&quot;&gt;&lt;a href=&quot;#Linux学习笔记四&quot; class=&quot;headerlink&quot; title=&quot;Linux学习笔记四&quot;&gt;&lt;/a&gt;Linux学习笔记四&lt;/h1&gt;&lt;h2 id=&quot;文件打包&quot;&gt;&lt;a href=&quot;#文件打包&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Linux学习笔记" scheme="https://albert-5.github.io/blogs/categories/Linux学习笔记/"/>
    
    
    <category term="学习笔记" scheme="https://albert-5.github.io/blogs/tags/学习笔记/"/>
    
    <category term="Linux" scheme="https://albert-5.github.io/blogs/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习笔记三</title>
    <link href="https://albert-5.github.io/blogs/aba12728/"/>
    <id>https://albert-5.github.io/blogs/aba12728/</id>
    <published>2022-02-07T03:19:23.000Z</published>
    <updated>2022-02-07T03:26:42.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux学习笔记三"><a href="#Linux学习笔记三" class="headerlink" title="Linux学习笔记三"></a>Linux学习笔记三</h1><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>准确的说是shell变量，就是计算机中用于记录一个值的符号，而这些符号将用于不同的运算处理中。通常变量与值都是一一对应的关系，可以通过表达式读取它的值并赋值给其他变量，也可以直接指定数值赋值给任意变量。</p><p>使用<code>declare</code>命令创建一个变量名为temp的变量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare temp  预声明而已</span><br></pre></td></tr></table></figure><p>使用<code>=</code>赋值运算符将变量temp进行赋值，shell中的赋值操作，<code>=</code>两边不能有空格</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 正确的赋值</span></span><br><span class="line">temp=nihao</span><br><span class="line"><span class="meta">#</span><span class="bash"> 错误的赋值</span></span><br><span class="line">temp = nihao</span><br></pre></td></tr></table></figure><p>读取变量的值，使用<code>echo</code>和<code>$</code>符号。（$符号用于表示引用一个变量的值）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $temp</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/linux_base/5-2.png"></p><p>变量类型有三种：</p><ul><li>当前shell进程私有用户自定义变量</li><li>shell本身内建的变量</li><li>从自定义变量导出的环境变量</li></ul><p>与上述相关的命令为：<code>set</code>、<code>env</code>、<code>export</code></p><p><code>set</code>：显示当前shell所有变量，包括其内建环境变量，用户自定义变量以及导出的环境变量；</p><p><code>env</code>：显示与当前用户相关的环境变量，还可以让命令在指定环境中运行；</p><p><code>export</code>：显示从shell中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量。</p><p><img src="https://doc.shiyanlou.com/linux_base/5-3.png"></p><p><strong>永久生效</strong></p><ul><li>永久的：需要修改配置文件，变量永久生效</li><li>临时的：使用<code>export</code>命令行声明即可，变量在关闭shell时失效。</li></ul><p><code>注</code>两个文件<code>/etc/bashrc</code>和<code>/etc/profile</code>分别存放的是shell变量和环境变量。</p><h2 id="命令的查找路径与顺序"><a href="#命令的查找路径与顺序" class="headerlink" title="命令的查找路径与顺序"></a>命令的查找路径与顺序</h2><p><strong>查看<code>PATH</code>环境变量的内容</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure><p>创建一个shell脚本文件，可以使用<code>gedit,vim,sublime</code>等工具编辑</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd mydir</span><br><span class="line">touch hello_shell.sh</span><br><span class="line">gedit hello_shell.sh</span><br></pre></td></tr></table></figure><p>在脚本中添加内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">for ((i=0; i&lt;10; i++));do</span><br><span class="line">    echo &quot;hello shell&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>为文件添加可执行权限，否则执行时会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 755 hello_shell.sh</span><br></pre></td></tr></table></figure><p>执行脚本即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd sh_filedir</span><br><span class="line">./hello_shell.sh</span><br></pre></td></tr></table></figure><p><strong>创建C语言的hello world程序</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit hello_world.c</span><br></pre></td></tr></table></figure><p>添加一下程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存后使用<code>gcc</code>生成可执行文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello_world hello_world.c</span><br></pre></td></tr></table></figure><p><strong>变量删除</strong></p><p>使用<code>unset</code>命令删除一个环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset mypath</span><br></pre></td></tr></table></figure><h2 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h2><p>与搜索有关的命令有：<code>whereis</code>、<code>which</code>、<code>find</code>、<code>locate</code></p><h3 id="whereis简单快速"><a href="#whereis简单快速" class="headerlink" title="whereis简单快速"></a><code>whereis</code>简单快速</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whereis who</span><br><span class="line">whereis find</span><br></pre></td></tr></table></figure><p><code>whereis</code>只能搜索二进制文件（-b），man帮助文件（-m）和源代码文件（-s）.</p><p><strong>locate快且全</strong></p><p>使用<code>locate</code>命令查找文件也不会遍历硬盘，它通过查询<code>/var/lib/mlocate/mlocate.db</code>数据库来检索信息。不过这个数据库也不是实时更新的，系统会使用定时任务每天自动执行<code>updatedb</code>命令来更新数据库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install locate</span><br><span class="line">sudo updatedb</span><br><span class="line"></span><br><span class="line">locate /etc/sh    查找`/etc`下所有以sh开头的文件</span><br></pre></td></tr></table></figure><p>查找某目录下的所有图片：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate /dir/*.jpg</span><br></pre></td></tr></table></figure><p><strong>which小而精</strong></p><p><code>which</code>本身是shell内建的一个命令，使用该命令来确定是否安装了某个指定的程序，因为它只从<code>PATH</code>环境变量指定的路径去搜索命令并且返回第一个搜索到的结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">which man</span><br><span class="line">which nginx</span><br><span class="line">which ping</span><br></pre></td></tr></table></figure><p><strong>find精而细</strong></p><p><code>find</code>不仅可以通过文件类型、文件名进行查找而且还可以根据文件的属性进行搜索，比如文件的时间戳和文件的权限等。</p><p>命令格式为：<code>find [path][option][action]</code></p><p>与时间有关的命令参数：</p><p><code>-atime</code>：最后访问时间</p><p><code>-ctime</code>：最后修改文件内容的时间</p><p><code>-mtime</code>：最后修改文件属性的时间</p><ul><li><code>-mtime n</code>：n为数字，表示为在n天之前的一天之内修改过的文件、</li><li><code>-mtime +n</code>：列出在n天之前被修改过的文件</li><li><code>mtime -n</code>：列出在n天之内被修改过的文件</li><li><code>newer file</code>：file作为一个已经存在的文件，列出比file还要新的文件名</li></ul><p><strong>实现黑客帝国里的数字雨</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install cmatrix</span><br><span class="line">cmatrix   # 运行</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux学习笔记三&quot;&gt;&lt;a href=&quot;#Linux学习笔记三&quot; class=&quot;headerlink&quot; title=&quot;Linux学习笔记三&quot;&gt;&lt;/a&gt;Linux学习笔记三&lt;/h1&gt;&lt;h2 id=&quot;环境变量&quot;&gt;&lt;a href=&quot;#环境变量&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Linux学习笔记" scheme="https://albert-5.github.io/blogs/categories/Linux学习笔记/"/>
    
    
    <category term="学习笔记" scheme="https://albert-5.github.io/blogs/tags/学习笔记/"/>
    
    <category term="Linux" scheme="https://albert-5.github.io/blogs/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习笔记二</title>
    <link href="https://albert-5.github.io/blogs/e9fdb125/"/>
    <id>https://albert-5.github.io/blogs/e9fdb125/</id>
    <published>2022-02-07T02:42:50.000Z</published>
    <updated>2022-02-07T03:26:42.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-学习笔记二"><a href="#Linux-学习笔记二" class="headerlink" title="Linux 学习笔记二"></a>Linux 学习笔记二</h1><h2 id="Linux文件组织目录结构"><a href="#Linux文件组织目录结构" class="headerlink" title="Linux文件组织目录结构"></a>Linux文件组织目录结构</h2><p>Linux的文件目录是树形结构的形式，每个目录不仅能使用本地磁盘分区的文件系统，也可以使用网络上的文件系统。比如可以利用网络文件系统（Network File System，NFS)服务器载入某特定目录。</p><p><strong>FHS标准：</strong> FHS（Filesystem Hierarchy Standard）中文全称为文件系统层次结构标准，它定义了两层规范，一，<code>/</code>下面的各个目录应该要放什么文件数据，例如<code>/etc</code>应该放置文件，<code>/bin</code>和<code>/sbin</code>则该放置可执行文件。二，针对<code>/usr</code>及<code>/var</code>这两个目录来定义。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree /</span><br></pre></td></tr></table></figure><p>如果提示<code>command not found</code>就先进行安装，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install tree</span><br></pre></td></tr></table></figure><h2 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h2><p>路径就是想去哪的路线，使用<code>cd</code>命令可以切换目录，在Linux里面使用，表示当前目录；<code>..</code>表示上一级目录（以<code>.</code>开头的文件都是隐藏文件，可以使用<code>ls -a</code>命令查看隐藏文件）；<code>-</code>表示上一次所在目录；<code>～</code>baishio </p><h2 id="文件的创建、移动、复制、重命名和编辑"><a href="#文件的创建、移动、复制、重命名和编辑" class="headerlink" title="文件的创建、移动、复制、重命名和编辑"></a>文件的创建、移动、复制、重命名和编辑</h2><p><strong>新建文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch filename</span><br></pre></td></tr></table></figure><p><strong>新建目录</strong></p><p>使用<code>mkdir</code>命令可以创建一个空目录，也可以同时指定创建目录的权限属性。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir mydir</span><br></pre></td></tr></table></figure><p>也可以使用<code>-p</code>参数，同时多级目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p father/son/grandson</span><br></pre></td></tr></table></figure><p><strong>文件的复制</strong></p><p>使用<code>cp</code>命令可以复制一个文件到指定的目录中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp filename mydir</span><br></pre></td></tr></table></figure><p><strong>目录的复制</strong></p><p>直接使用<code>cp</code>命令复制一个目录会发生错误，所以需要天界<code>-r</code>或<code>-R</code>参数，表示递归复制。</p><p><strong>删除文件</strong></p><p>使用<code>rm</code>命令删除一个文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm test</span><br></pre></td></tr></table></figure><p>但如果想要删除一些为只读权限的文件，直接使用<code>rm</code>删除会显示一个提示：<em>是否删除有写保护的普通文件？</em>要想忽略这个提示，直接删除文件，就需要使用<code>-f</code>参数强制删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f test</span><br></pre></td></tr></table></figure><p><strong>删除目录</strong></p><p>跟复制目录一样，要删除一个目录一样    也需要加上参数<code>-r</code>或<code>-</code>R</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -r family</span><br><span class="line">遇到权限不足删除不了的目录可以和删除文件一样加上`-f`参数</span><br></pre></td></tr></table></figure><p><strong>文件的移动</strong></p><p>使用<code>mv</code>（move or rename files）命令移动文件（剪切）。命令格式为<code>mv 源文件 目的目录</code></p><p><strong>重命名文件</strong></p><p><code>mv</code>命令除了能移动文件外，还能给文件重命名。命令格式为<code>mv 旧的文件名 新的文件名</code></p><p>批量操作下，当前命令就有点力不从心了，这时候可以使用<code>rename</code>来实现。<code>rename</code>命令并不是内置命令，若提示无命令可以使用<code>sudo apt-get install rename</code>命令来安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch file&#123;1..5&#125;.txt</span><br><span class="line">rename 's/\.txt/\.c\' *.txt</span><br><span class="line">rename 'y/a-z/A-Z/' *.c</span><br></pre></td></tr></table></figure><p><code>rename</code>是先将第二个参数的通配符匹配所有后缀为<code>.txt</code>的文件，然后使用第一个参数提供的正则表达式将匹配的这些文件的<code>.txt</code>后缀替换为<code>.c</code>。</p><p><strong>使用</strong><code>cat tac和nl</code>命令查看文件</p><p>前两个文件都是用来打印文件内容到标准输出，其中cat为正序显示，tac为倒序显示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat passwd</span><br><span class="line">cat -n passwd   带有行号</span><br><span class="line">cat -nl passwd  添加行号并打印</span><br></pre></td></tr></table></figure><p><strong>使用<code>more</code>和<code>less</code>命令分页查看文件</strong></p><p><code>more</code>和<code>less</code>是用来阅读一个文件的内容的，比如man手册内部就是使用<code>less</code>来显示内容的。其中，<code>more</code>命令比较简单，只能向一个方向滚动，而<code>less</code>为基于<code>more</code>和<code>vi</code>开发的。</p><p>使用<code>more</code>命令打开文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more filename</span><br></pre></td></tr></table></figure><p>打开后默认只显示一屏的内容，终端底部会显示当前阅读的进度，可以使用<code>Enter</code>键向下滚动一行，使用<code>Space</code>键向下滚动一屏，按下<code>h</code>显示帮助，<code>q</code>退出。</p><p><strong>使用<code>head</code>和<code>tail</code>命令查看文件</strong></p><p>该命令是查看文件的头几行，默认是10行；也可以使用<code>-n</code>参数，后面紧跟行数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tail filename</span><br><span class="line">tail -n 1 filename  只查看一行</span><br></pre></td></tr></table></figure><p><strong>查看文件类型<code>file</code></strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file filename</span><br></pre></td></tr></table></figure><p><strong>嘻哈一下</strong></p><p>开天眼方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xeyes</span><br><span class="line">nohup xeyes &amp;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux-学习笔记二&quot;&gt;&lt;a href=&quot;#Linux-学习笔记二&quot; class=&quot;headerlink&quot; title=&quot;Linux 学习笔记二&quot;&gt;&lt;/a&gt;Linux 学习笔记二&lt;/h1&gt;&lt;h2 id=&quot;Linux文件组织目录结构&quot;&gt;&lt;a href=&quot;#Linu</summary>
      
    
    
    
    <category term="Linux学习笔记" scheme="https://albert-5.github.io/blogs/categories/Linux学习笔记/"/>
    
    
    <category term="学习笔记" scheme="https://albert-5.github.io/blogs/tags/学习笔记/"/>
    
    <category term="Linux" scheme="https://albert-5.github.io/blogs/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习笔记一</title>
    <link href="https://albert-5.github.io/blogs/d27d9f8c/"/>
    <id>https://albert-5.github.io/blogs/d27d9f8c/</id>
    <published>2022-02-07T02:40:09.000Z</published>
    <updated>2022-02-07T03:26:42.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux学习笔记一"><a href="#Linux学习笔记一" class="headerlink" title="Linux学习笔记一"></a>Linux学习笔记一</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Linux基础Ctrl相关操作常用按键"><a href="#Linux基础Ctrl相关操作常用按键" class="headerlink" title="Linux基础Ctrl相关操作常用按键"></a>Linux基础<em>Ctrl</em>相关操作常用按键</h3><table><thead><tr><th>按键</th><th>作用</th></tr></thead><tbody><tr><td><strong>Ctrl D</strong></td><td>键盘输入结束或退出终端</td></tr><tr><td><strong>Ctrl S</strong></td><td>暂停当前程序，暂停后按下任意键恢复运行</td></tr><tr><td><strong>Ctrl Z </strong></td><td>将当前程序放到后台运行，恢复到前台为命令<em>fg</em></td></tr><tr><td><strong>Ctrl a</strong></td><td>将光标移至输入行头，相当于<em>Home</em>键</td></tr><tr><td><strong>Ctrl e</strong></td><td>将光标移至行末，相当于<em>End</em>键</td></tr><tr><td><strong>Ctrl k</strong></td><td>删除从光标所在位置到行末</td></tr><tr><td><strong>Alt Backspace</strong></td><td>向前删除一个词</td></tr><tr><td><strong>Shift PgUp</strong></td><td>将终端显示向上滚动</td></tr><tr><td><strong>Shift PgDn</strong></td><td>将终端显示向下滚动</td></tr><tr><td><strong>Ctrl C</strong></td><td>终止程序运行</td></tr></tbody></table><h3 id="历史输入命令"><a href="#历史输入命令" class="headerlink" title="历史输入命令"></a>历史输入命令</h3><p>使用键盘键盘上的 <strong>↑</strong> 就能恢复之前输入过的命令。</p><h3 id="使用通配符"><a href="#使用通配符" class="headerlink" title="使用通配符"></a>使用通配符</h3><p>通配符是一种特殊语句，主要由星号（*）和问号（？），用来对字符串进行模糊匹配（比如文件名或参数名）。在查找文件夹时，可以使用它来代替一个或多个真正字符；在不知道真正字符或者懒得输入完整名字时，通常可以使用通配符代替一个或多个真正字符。</p><p><code>注</code>：终端里输入的通配符是由 <strong>Shell</strong> 处理的，并不是由所涉及的命令语句处理的。</p><p>在具体操作时，进入到某个目录中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd 目录</span><br></pre></td></tr></table></figure><p>然后使用<code>touch</code>命令创建文件，后缀为<strong>.txt</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file1.txt file2.txt</span><br></pre></td></tr></table></figure><p>但假若过了很长时间，已经忘记了这两个文件，现在又想在一大堆文件中找到这两个文件，就可以使用通配符来寻找。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls *.txt</span><br></pre></td></tr></table></figure><p>不仅如此，在创建文件时也可以使用通配符来批量操作，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file_&#123;1..5&#125;.txt</span><br></pre></td></tr></table></figure><p><strong>Shell常用通配符</strong></p><table><thead><tr><th><strong>字符</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td><strong>*</strong></td><td>匹配0或多个字符</td></tr><tr><td><strong>？</strong></td><td>匹配任意一个字符</td></tr><tr><td><strong>[list]</strong></td><td>匹配<strong>list</strong>中的任意单一字符</td></tr><tr><td><strong>[^list]</strong></td><td>匹配除<strong>list</strong>中的任意单一字符以外的字符</td></tr><tr><td><strong>[c1-c2]</strong></td><td>匹配c1-c2中的任意单一字符，如[0-9] [a-z]</td></tr><tr><td><strong>{string1, string2, …….}</strong></td><td>匹配string1或string2（或更多）其一字符串</td></tr><tr><td><strong>{c1..c2}</strong></td><td>匹配c1-c2中全部字符，如{1..10}</td></tr></tbody></table><h3 id="在命令行中使用帮助"><a href="#在命令行中使用帮助" class="headerlink" title="在命令行中使用帮助"></a>在命令行中使用帮助</h3><p>在Linux环境中，使用<code>man</code>命令，全称为<code>Manual pages</code>，这是UNIX操作系统中在线软件文档的一种普遍的形式，内容包括计算机程序（包括库和系统调用）、正式的标准和惯例。甚至是抽象的概念。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man &lt;command_name&gt;</span><br></pre></td></tr></table></figure><h3 id="一个有趣的例子"><a href="#一个有趣的例子" class="headerlink" title="一个有趣的例子"></a>一个有趣的例子</h3><p>一个可以输出图形字符的命令<code>banner</code>，具体操作如下：</p><p>首先使用如下命令安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install sysvbanner</span><br><span class="line"></span><br><span class="line">banner love</span><br><span class="line">更改字体操作，使用默认已经安装的一个命令`printerbanner`</span><br><span class="line">printerbanner -w 50 A</span><br></pre></td></tr></table></figure><h2 id="用户以及权限管理"><a href="#用户以及权限管理" class="headerlink" title="用户以及权限管理"></a>用户以及权限管理</h2><p> Linux是一个可以实现多用户登录的操作系统，多用户可共享一些主机资源，但分别有自己的用户空间，用于存放各自的文件。实际上这些用户的文件都是存放在同一个物理磁盘上甚至是同一个逻辑分区或者目录上的，由于Linux的<strong>用户管理</strong>和<strong>权限机制</strong>，不同的用户不可以轻易的查看或修改彼此的文件。</p><p>在终端输入命令 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">who am i</span><br><span class="line">或者</span><br><span class="line">who mom likes</span><br></pre></td></tr></table></figure><p>输出的第一列表表示打开当前伪终端的用户的用户名（要查看当前登录用户的用户名，去掉空格直接使用<code>whoami</code>)，第二列的<code>pts/0</code>中的<code>pts</code>表示伪终端，所谓的伪是相对于<code>/dev/tty</code>设备而言的，第三列则表示当前伪终端的启动时间。</p><p>但要注意的是有些环境中使用<code>who am i</code>或<code>who mom likes</code>并不会输出任何内容，因为当前的SHELL不是登录时的SHELL，并没有用户与who的stdin相关联，因此不会输出任何内容。只需要在打开一个登录SHELL的终端如<code>Tmux</code>或者通过<code>ssh</code>登录到本机，再在新的终端里执行命令。</p><p><code>who</code>命令其他常用参数</p><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td><strong>-a</strong></td><td>打印能打印的内容</td></tr><tr><td><strong>-d</strong></td><td>打印死掉的进程</td></tr><tr><td><strong>-m</strong></td><td>同<code>am i</code>,<code>mom likes</code></td></tr><tr><td><strong>-q</strong></td><td>打印当前登录用户以及用户名</td></tr><tr><td><strong>-u</strong></td><td>打印当前登录用户登录信息</td></tr><tr><td><strong>-r</strong></td><td>打印运行等级</td></tr></tbody></table><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>在Linux系统里，<code>root</code>账户拥有整个系统最高的权限，比如新建和添加用户。</p><p>一般登录系统时都是以普通账户的身份登录的，要创建用户需用<code>root</code>权限，就要用到<code>sudo</code>命令。前提是：一，要知道当前登录用户的密码；二，当前用户必须在<code>sudo</code>用户组。</p><p><code>su &lt;user&gt;</code>: 切换到用户组，输入时需要输入目标用户的密码</p><p><code>sudo &lt;cmd&gt;</code>: 以特权级别运行cmd命令，需要当前用户属于sudo用户组，且需要输入当前用户的密码</p><p><code>su - &lt;user&gt;</code>: 命令也是切换用户，但是同时用户的环境变量和工作目录也会跟着改变目标用户所对应的。</p><p>操作如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser name</span><br></pre></td></tr></table></figure><p>根据提示来设置用户名密码以及有关操作。而且该命令不但可以添加用户到系统，同时也会默认为新用户在/home目录下创建一个工作目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /home</span><br></pre></td></tr></table></figure><p>该命令可以查看到当前用户状态，现在已经创建好一个用户，并且可以使用创建的用户登录，使用以下命令来切换登录用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su -l name</span><br></pre></td></tr></table></figure><p>按照提示输入密码即可。</p><p>退出当前用户和退出终端一样，可以使用<code>exit</code>命令或者使用快捷键<code>Ctrl D</code>。</p><h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><p>在Linux里面每个用户都有一个归属（用户组）,用户组简单地理解为就是组用户的集合，共享一些资源和权限，同时拥有私有资源。</p><p><strong>使用<code>groups</code>命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groups name</span><br></pre></td></tr></table></figure><p>冒号之前表示用户，后面表示该用户所属的用户组。默认情况下载sudo用户组里的可以使用sudo命令获得root权限，用户也可以使用sudo命令，可以查看<code>/etc/sudoers.d/用户名</code>文件，在<code>/etc/sudoers.d</code>目录下创建了这个文件，从而给用户赋予了sudo权限。</p><p><strong>查看<code>/etc/group</code>文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/group | sort</span><br></pre></td></tr></table></figure><p><code>cat</code>命令用户读取指定文件的内容并打印到终端输出。<code>| sort</code>表示将读取的文本进行一个字典排序再输出。</p><p>不仅如此，还可以使用<code>grep</code>命令过滤掉一些不想看到的内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/group | grep -E 'content'</span><br></pre></td></tr></table></figure><p><code>/etc/group</code>文件格式说明</p><p>该格式的内容包括用户组(group)、用户组口令、GID(组ID)以及该用户组所包含的用户user，每个用户组一条记录。格式如下：</p><ul><li>group_name:password:GID:user_list</li></ul><p><strong>讲其他用户加入到sudo用户组</strong></p><p>默认情况下创建的用户时不具有root权限的，也不再sudo用户组，可以让其加入到sudo用户组从而获取权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su -l name</span><br><span class="line">sudo ls</span><br></pre></td></tr></table></figure><p>此操作后会提示name不在sudoers文件中，意思就是name不在sudo用户组中，使用<code>usermod</code>命令可以为用户添加用户组，但使用该命令需要有root权限。</p><p>可以通过<code>sudo passwd shiyanlou</code>进行设置，操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">groups name</span><br><span class="line">sudo usermod -G sudo name</span><br><span class="line">groups name</span><br></pre></td></tr></table></figure><p>这个时候用户name就可以使用sudo获取root权限。</p><h3 id="删除用户和用户组"><a href="#删除用户和用户组" class="headerlink" title="删除用户和用户组"></a>删除用户和用户组</h3><p>删除用户较为简单，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo deluser name --remove-home</span><br></pre></td></tr></table></figure><p>使用<code>--remove-home</code>参数在删除用户时会一并将该用户的工作目录一并删除。如果不使用则系统会自动在<code>/home</code>目录为该用户保留工作目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo deluser name</span><br><span class="line">cat /etc/group | grep 'name'</span><br><span class="line">ls /home</span><br></pre></td></tr></table></figure><p>删除用户组可以使用<code>groupdel</code>，命令，若群里包含某些用户，则先删除这些用户后才能删除群组。</p><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><p>所谓文件权限就是文件的访问控制权限，即那些用户和群组可以访问文件以及可以执行什么样的操作。</p><p>Linux系统是一个典型的多用户系统，不同的用户处于不同的状态，也就有不同的访问权限。</p><p><strong>查看文件权限</strong></p><p><code>ls</code>命令可以列出并显示当前目录下的文件，使用较长格式列出文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/linux_base/3-9.png"></p><p><img src="https://doc.shiyanlou.com/linux_base/3-10.png"></p><p><strong><code>注：</code>Linux里面一切皆文件。</strong></p><p>设备文件（<code>/dev</code>目录下有各种设备文件），<code>socket</code>网络套接字，<code>pipe</code>是管道，<code>软连接文件</code>：链接文件分为两类，另一类是硬链接，软连接类似于windows的快捷方式。</p><p><strong>文件权限</strong></p><p>读权限，使用<code>cat &lt;file name&gt;</code>命令用来读取某个文件的内容；写权限，表示可以对某个文件进行编辑和修改；执行权限，指可以运行的二进制或者脚本文件，如同windows的<code>exe</code>后缀的文件，<strong>一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件。</strong></p><p><strong>文件大小</strong></p><p>以inode结点大小为单位来表示文件的大小，可以给ls加上<code>-lh</code>参数来直观的查看文件大小。</p><p>ls -lh</p><p>ls -a(all)</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ls</span> -<span class="keyword">lh</span></span><br><span class="line"><span class="keyword">ls</span> -<span class="keyword">a</span>(<span class="keyword">all</span>)</span><br><span class="line"><span class="keyword">ls</span> -<span class="keyword">al</span>   查看某一个目录的完整属性，而不是显示目录里面的文件属性</span><br><span class="line"><span class="keyword">ls</span> -<span class="keyword">dl</span> &lt;目录名&gt;</span><br><span class="line"><span class="keyword">ls</span> -asSh 其中s为显示文件大小，S为按文件大小排序</span><br></pre></td></tr></table></figure><h3 id="变更文件所有者"><a href="#变更文件所有者" class="headerlink" title="变更文件所有者"></a>变更文件所有者</h3><p>切换到name用户，然后在<code>/home/name</code>目录新建一个文件，并命名为iPhone13</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">su - name</span><br><span class="line">pwd</span><br><span class="line">touch iphone13</span><br><span class="line">ls -ah iphone13</span><br><span class="line"></span><br><span class="line">cd /home/name</span><br><span class="line">ls iphone13</span><br><span class="line">sudo chown shiyanlou iphone13</span><br></pre></td></tr></table></figure><h3 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><p>文件的有两种：</p><p>方式一：二进制数字表示</p><p><img src="https://doc.shiyanlou.com/linux_base/3-14.png"></p><p>每个文件有三组固定的权限，分别对应拥有者，所属用户组，其他用户。文件的读写执行对应字母<code>rwx</code>，以二进制表示就是<code>111</code>，用十进制表示就是<code>7</code>，权限表示为<code>rwx-rwx-rwx-</code>。</p><p>修改权限操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 filename</span><br><span class="line">ls -alh filename</span><br></pre></td></tr></table></figure><p>方式二：加减赋值操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod go-rw filename</span><br></pre></td></tr></table></figure><p><code>g、o、u</code>分别表示group（用户组）、others（其他用户）和user（用户），<code>+、-</code>分别表示增加和去掉相应的权限。</p><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p><strong><code>adduser</code>和<code>useradd</code>的区别是什么</strong></p><p><code>useradd</code>只创建用户，不会创建用户密码和工作目录，创建玩了需要使用<code>passwd &lt;username&gt;</code>去设置新用户和密码。</p><p><code>adduser</code>在创建用户的同时，会创建工作目录和密码（提示设置）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux学习笔记一&quot;&gt;&lt;a href=&quot;#Linux学习笔记一&quot; class=&quot;headerlink&quot; title=&quot;Linux学习笔记一&quot;&gt;&lt;/a&gt;Linux学习笔记一&lt;/h1&gt;&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Linux学习笔记" scheme="https://albert-5.github.io/blogs/categories/Linux学习笔记/"/>
    
    
    <category term="学习笔记" scheme="https://albert-5.github.io/blogs/tags/学习笔记/"/>
    
    <category term="Linux" scheme="https://albert-5.github.io/blogs/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux笔记</title>
    <link href="https://albert-5.github.io/blogs/e511c25d/"/>
    <id>https://albert-5.github.io/blogs/e511c25d/</id>
    <published>2022-01-17T10:29:21.000Z</published>
    <updated>2022-02-07T03:26:42.912Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>2021年个人总结</title>
    <link href="https://albert-5.github.io/blogs/491cb1e0/"/>
    <id>https://albert-5.github.io/blogs/491cb1e0/</id>
    <published>2021-12-31T13:26:30.000Z</published>
    <updated>2022-01-17T10:22:50.157Z</updated>
    
    <content type="html"><![CDATA[<p>2021年，过的很快<br>感觉什么都没有发生，又感觉不知发生了什么。<br>一些重要的事情还是有必要留恋一下的。<br>谈起2020年不算是友好的一年<br>去年还觉得“2020”是“爱你爱你”<br>没想到最后成了“二你二你”，生活也是爱开玩笑，明明白白二了我一回<br>当然也可能是因为自己不争气。<br>研究生初试成绩不理想，复试也多次碰壁；<br>毕业呢也并没有感受到快乐，那一句句“年后见”、“兄弟们九月份见”再也没有了，连每晚的“两岸猿叫”都没了；<br>毕业也好，也不好。<br>幸运的是还有书读，还有学上，也来到了之前想来的城市<br>甚至还能在一志愿的学校学习，这该死的缘分。<br>在这里也认识一群新的伙伴，对我也照顾挺多的，我很幸运每一段路上遇到的每个人。<br>不过我现在还有些许迷茫，但我从未放弃自己追逐的目标和方向。<br>总的来说，2021虽有不舍和遗憾<br>但我相信2022仍未来可期，努力有收获，所求有所得！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2021年，过的很快&lt;br&gt;感觉什么都没有发生，又感觉不知发生了什么。&lt;br&gt;一些重要的事情还是有必要留恋一下的。&lt;br&gt;谈起2020年不算是友好的一年&lt;br&gt;去年还觉得“2020”是“爱你爱你”&lt;br&gt;没想到最后成了“二你二你”，生活也是爱开玩笑，明明白白二了我一回&lt;br</summary>
      
    
    
    
    <category term="年度总结" scheme="https://albert-5.github.io/blogs/categories/年度总结/"/>
    
    
    <category term="总结" scheme="https://albert-5.github.io/blogs/tags/总结/"/>
    
    <category term="2021" scheme="https://albert-5.github.io/blogs/tags/2021/"/>
    
  </entry>
  
  <entry>
    <title>贪婪算法</title>
    <link href="https://albert-5.github.io/blogs/443f7531/"/>
    <id>https://albert-5.github.io/blogs/443f7531/</id>
    <published>2021-11-06T08:19:16.000Z</published>
    <updated>2021-11-06T11:13:40.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>贪心算法（又称为贪婪算法 Greedy Algorithm）指的是，在对问题求解时，总是做出在当前看来是最好的选择，换句话说，就是通过一步步寻找局部最优解的方式来寻找全局最优解。<br>贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是<code>局部最优解决定全局最优解</code>。也就是说问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。</p><h3 id="找零问题"><a href="#找零问题" class="headerlink" title="找零问题"></a>找零问题</h3><p>假设商店老板需要找零<code>n</code>元钱，钱币的面额有100元，50元，20元，5元，1元，如何找零使得所需钱币的数量最少？（并没有面额10的钱币）<br>如果是找零276元呢？$100<em>2+50</em>1+10<em>2+5</em>1+1*1=276$<br>代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># t表示商店有的零钱面额</span></span><br><span class="line">t = [<span class="number">100</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">5</span>, <span class="number">1</span>]</span><br><span class="line"><span class="comment"># n表示n元钱</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(t, n)</span>:</span></span><br><span class="line">    m = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(t))]</span><br><span class="line">    <span class="keyword">for</span> j, money <span class="keyword">in</span> enumerate(t):</span><br><span class="line">        m[j] = n // money  <span class="comment"># 除法向下取整</span></span><br><span class="line">        n = n % money  <span class="comment"># 取余</span></span><br><span class="line">    <span class="keyword">return</span> m, n</span><br><span class="line"></span><br><span class="line">print(change(t, <span class="number">276</span>))</span><br></pre></td></tr></table></figure></p><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>常见的背包问题有整数背包和部分背包问题。<br>一个小偷在某个商店发现有$n$个商品，第$i$个商品价值$V_i$元，重$W_i$千克。他希望拿走的东西价值最高，但是他的背包的容量是有限的，最多只能容纳$W$千克的东西，那么他应该拿走那些东西?<br><code>0-1背包</code>：对于一个商品，小偷要么完整拿走，要么一点不拿，即不能拿走其中一部分，或把一个东西拿走多次。<br><code>分数背包</code>：对于一个商品，小偷可以拿走其中的一部分。<br>很明显，贪心算法对于分数背包问题肯定能得到最优解，首先计算每个物品的单位重量的价值，然后将它们按照降序排列，接着开始拿取物资即可，只要装得下全部的该类商品那么就可以完全装进去；如果不能全部装下就直到背包装满为止。<br>对于这种问题，<code>0-1背包</code>问题肯定装不满，但不排除偶然可以的情况，并不适用于所有的整数背包问题。<br>代码实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每个商品用元组表示（价值，重量）</span></span><br><span class="line">goods = [(<span class="number">60</span>, <span class="number">10</span>), (<span class="number">100</span>, <span class="number">20</span>), (<span class="number">120</span>, <span class="number">30</span>)]</span><br><span class="line">goods.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>]/x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># w表示背包容量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fractional_backpack</span><span class="params">(goods, w)</span>:</span></span><br><span class="line">    <span class="comment"># m表示拿走的商品数量</span></span><br><span class="line">    total_v = <span class="number">0</span></span><br><span class="line">    m = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(goods))]</span><br><span class="line">    <span class="keyword">for</span> i, (prize, weight) <span class="keyword">in</span> enumerate(goods):</span><br><span class="line">        <span class="keyword">if</span> w &gt;= weight:</span><br><span class="line">            m[i] = <span class="number">1</span></span><br><span class="line">            total_v += prize</span><br><span class="line">            w -= weight</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            m[i] = w/weight</span><br><span class="line">            total_v += m[i] * prize</span><br><span class="line">            w = <span class="number">0</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> m, total_v</span><br><span class="line"></span><br><span class="line">res1, res2 = fractional_backpack(goods, <span class="number">50</span>)</span><br><span class="line">print(res1, res2)</span><br></pre></td></tr></table></figure></p><p>输出结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">==================== RESTART: C:/Users/DELL/Desktop/test.py ====================</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0.6666666666666666</span>] <span class="number">240.0</span></span><br></pre></td></tr></table></figure></p><h3 id="拼接最大数字问题"><a href="#拼接最大数字问题" class="headerlink" title="拼接最大数字问题"></a>拼接最大数字问题</h3><p>有$n$个非负数，将其按照字符串拼接的方式拼接成一个整数。如何可以使得拼接得到的整数最大？<br>例如：32，94, 128，1286， 6， 71可以拼接得到的最大整数位9471321286128<br>但字符串比较数字大小和整数比较数字大小的方式不一样，字符串比较大小就是首先看第一位，大的就大，可是一个字符长而另一个短如何比较就成了问题。<br>思路如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'96'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">'97'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a+b <span class="keyword">if</span> a&gt;b <span class="keyword">else</span> b+a</span><br><span class="line"><span class="string">'9796'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'128'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b =<span class="string">'1286'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a+b</span><br><span class="line"><span class="string">'1281286'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b+a</span><br><span class="line"><span class="string">'1286128'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a+b <span class="keyword">if</span> a+b &gt; b+a <span class="keyword">else</span> b+a</span><br><span class="line"><span class="string">'1286128'</span></span><br></pre></td></tr></table></figure></p><p>数字拼接代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> cmp_to_key</span><br><span class="line">li = [<span class="number">30</span>, <span class="number">94</span>, <span class="number">128</span>, <span class="number">1286</span>, <span class="number">8</span>, <span class="number">71</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xy_cmp</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="comment"># 其中1表示x&gt;y</span></span><br><span class="line">    <span class="keyword">if</span> x+y &lt; y+x:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> x+y &gt; y+x:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">number_join</span><span class="params">(li)</span>:</span></span><br><span class="line">    li = list(map(str, li))</span><br><span class="line">    li.sort(key=cmp_to_key(xy_cmp))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>.join(li), li</span><br><span class="line"></span><br><span class="line">print(number_join(li))</span><br></pre></td></tr></table></figure></p><p>输出结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">==================== RESTART: C:/Users/DELL/Desktop/test.py ====================</span><br><span class="line"><span class="number">94871301286128</span></span><br></pre></td></tr></table></figure></p><h4 id="扩充：cmp-to-key函数"><a href="#扩充：cmp-to-key函数" class="headerlink" title="扩充：cmp_to_key函数"></a>扩充：cmp_to_key函数</h4><p>该函数作用是比较<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lagestnumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> functools <span class="keyword">import</span> cmp_to_key</span><br><span class="line">    temp = list(map(str, nums))</span><br><span class="line">    temp.sort(key=cmp_to_key(<span class="keyword">lambda</span> x, y: int(x+y) - int(y+x)), reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>.join(temp <span class="keyword">if</span> temp[<span class="number">0</span>] != <span class="string">'0'</span> <span class="keyword">else</span> <span class="string">'0'</span>)</span><br></pre></td></tr></table></figure></p><p>上面这个函数有传入两个参数x,y，当x&gt;y时返回1，等于0时返回0，否则的话返回-1,。它在list的工作原理就是将列表中的元素去两两比较，当cmp返回的是正数时交换两元素。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;贪心算法&quot;&gt;&lt;a href=&quot;#贪心算法&quot; class=&quot;headerlink&quot; title=&quot;贪心算法&quot;&gt;&lt;/a&gt;贪心算法&lt;/h2&gt;&lt;p&gt;贪心算法（又称为贪婪算法 Greedy Algorithm）指的是，在对问题求解时，总是做出在当前看来是最好的选择，换句话说</summary>
      
    
    
    
    <category term="算法" scheme="https://albert-5.github.io/blogs/categories/算法/"/>
    
    
    <category term="python" scheme="https://albert-5.github.io/blogs/tags/python/"/>
    
    <category term="贪婪算法" scheme="https://albert-5.github.io/blogs/tags/贪婪算法/"/>
    
  </entry>
  
  <entry>
    <title>立体视觉计算视差图</title>
    <link href="https://albert-5.github.io/blogs/18650a07/"/>
    <id>https://albert-5.github.io/blogs/18650a07/</id>
    <published>2021-10-23T07:59:34.000Z</published>
    <updated>2021-10-23T13:25:03.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="立体视觉计算视差图-stereo-vision"><a href="#立体视觉计算视差图-stereo-vision" class="headerlink" title="立体视觉计算视差图 stereo vision"></a>立体视觉计算视差图 stereo vision</h1><h2 id="一、实验原理"><a href="#一、实验原理" class="headerlink" title="一、实验原理"></a>一、实验原理</h2><h3 id="1、立体图像"><a href="#1、立体图像" class="headerlink" title="1、立体图像"></a>1、立体图像</h3><p>立体视差也就是立体视像，是基于双眼视差所获得的深度知觉。所谓立体图像，其实就是有两台水平的相机对同一场景进行观测，这时，得到的两幅图像就有了相同的图像平面，图像的行是对齐的。<br>参考图如下所示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/10/23/q8euCFYdoKbZQxf.jpg" alt="原理图1.jpg" title>                </div>                <div class="image-caption">原理图1.jpg</div>            </figure><br>由于采用的图像是<a href>官网</a>提供的图片，是已经矫正过的，所以这两幅图就可以看成是理想的。根据偏移可以计算出深度，公式如下：<br>$$Z=\frac{fb}{x_l-x_r}$$<br>其中，$f$是焦距，$b$是两个相机中心的距离，$x_l$和$x_r$分别是左右两个图像中的$x$坐标，分开照相机中心的距离成为基线。</p><h3 id="2、计算视差"><a href="#2、计算视差" class="headerlink" title="2、计算视差"></a>2、计算视差</h3><p><strong>在立体重建算法中，对图像中的每个像素尝试不同的偏移，并按照局部图像周围归一化的互相关值，选择具有最好分数的偏移，记录该最佳偏移。</strong></p><h3 id="3、归一化互相关NCC"><a href="#3、归一化互相关NCC" class="headerlink" title="3、归一化互相关NCC"></a>3、归一化互相关NCC</h3><p>归一化互相关算法原理为：对于已经矫正过的两个图像$I_1$和$I_2$，ncc算法对图像$I_1$一个待匹配像素构建一个匹配窗口，在另一个图像的极线上对每个像素构建匹配窗口与待匹配像素匹配窗口计算相关性，相关性越高则表示匹配度越好。</p><p>下面对每个像素周围的像素块来计算归一化相关值，公式如下：<br>$$ncc(I_1,I_2)=\frac{\Sigma_x(I_1(X)-\mu_1)(I_2(X)-\mu_2)}{\sqrt{\Sigma_x(I_1(X)-\mu_1)^2}\sqrt{\Sigma_x(I_2(X)-\mu_2)^2}}$$</p><h2 id="二、实验步骤"><a href="#二、实验步骤" class="headerlink" title="二、实验步骤"></a>二、实验步骤</h2><p>得到计算视差图的基本步骤如下：</p><ul><li>校正：校正的目的是为了使得两帧图像的光心处于同一水平线上，便于后续的ncc操作。</li><li>特征匹配：利用ncc做匹配，右视图中与左视图待测像素同一水平线上相关性最高即为最优匹配，完成匹配后，需要记录视差d，即待测像素水平方向$x_l$和匹配像素水平方向$x_r$之间的差值，再由上述推导的深度公式计算出深度$Z$，最终可以得到一个与原始图像尺寸相同的视差图。</li><li>由于不用窗口值会影响得到的视差图的效果，因此在不同窗口下对图像视差图进行求取，以此得到多个视差图。</li></ul><h2 id="三、实验代码"><a href="#三、实验代码" class="headerlink" title="三、实验代码"></a>三、实验代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.ndimage <span class="keyword">import</span> filters</span><br><span class="line"><span class="keyword">import</span> stereo</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> misc</span><br><span class="line"><span class="keyword">from</span> scipy.ndimage <span class="keyword">import</span> filters</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot  <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 定义归一化ncc方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plane_sweep_ncc</span><span class="params">(iml, imr, start, steps, wid)</span>:</span></span><br><span class="line">    <span class="comment"># 使用归一化的互相关计算视差图像</span></span><br><span class="line">    (m, n) = iml.shape</span><br><span class="line">    print(iml.shape)</span><br><span class="line">    meanl = zeros((m, n))</span><br><span class="line">    meanr = zeros((m, n))</span><br><span class="line">    <span class="comment"># meanl = zeros_like(iml)</span></span><br><span class="line">    <span class="comment"># meanr = zeros_like(imr)</span></span><br><span class="line">    s = np.zeros((m, n))</span><br><span class="line">    s_l = np.zeros((m, n))</span><br><span class="line">    s_r = np.zeros((m, n))</span><br><span class="line">    <span class="comment"># 保存深度平面的数据</span></span><br><span class="line">    deepmaps = np.zeros((m, n, steps))</span><br><span class="line">    <span class="comment"># 计算图像的平均值</span></span><br><span class="line">    filters.uniform_filter(iml, wid, meanl)</span><br><span class="line">    filters.uniform_filter(imr, wid, meanr)</span><br><span class="line">    <span class="comment"># 图像归一化处理</span></span><br><span class="line">    norml = iml - meanl</span><br><span class="line">    normr = imr - meanr</span><br><span class="line">    <span class="comment"># 计算不同视差</span></span><br><span class="line">    <span class="keyword">for</span> disp <span class="keyword">in</span> range(steps):</span><br><span class="line">        <span class="comment"># 将左边图像加到右边的图像上</span></span><br><span class="line">        filters.uniform_filter(np.roll(norml, -disp - start) * normr, wid, s)</span><br><span class="line">        filters.uniform_filter(np.roll(norml, -disp - start) * np.roll(norml, -disp - start), wid, s_l)</span><br><span class="line">        <span class="comment"># 和反归一化</span></span><br><span class="line">        filters.uniform_filter(normr * normr, wid, s_r)</span><br><span class="line">        <span class="comment"># 保存ncc的值</span></span><br><span class="line">        deepmaps[:, :, disp] = s / sqrt(s_l * s_r)</span><br><span class="line">    <span class="comment"># 为每个像素选取最佳深度</span></span><br><span class="line">    <span class="keyword">return</span> argmax(deepmaps, axis=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 高斯滤波器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plane_sweep_guess</span><span class="params">(iml, imr, start, steps, wid)</span>:</span></span><br><span class="line">    <span class="comment"># 使用高斯的互相关计算视差图像</span></span><br><span class="line">    (m, n) = iml.shape</span><br><span class="line"><span class="comment">#     print(iml.shape)</span></span><br><span class="line">    meanl = zeros((m, n))</span><br><span class="line">    meanr = zeros((m, n))</span><br><span class="line">    <span class="comment"># meanl = zeros_like(iml)</span></span><br><span class="line">    <span class="comment"># meanr = zeros_like(imr)</span></span><br><span class="line">    s = np.zeros((m, n))</span><br><span class="line">    s_l = np.zeros((m, n))</span><br><span class="line">    s_r = np.zeros((m, n))</span><br><span class="line">    <span class="comment"># 保存深度平面的数据</span></span><br><span class="line">    deepmaps = np.zeros((m, n, steps))</span><br><span class="line">    <span class="comment"># 计算图像的平均值</span></span><br><span class="line">    filters.gaussian_filter(iml, wid, <span class="number">0</span>, meanl)</span><br><span class="line">    filters.gaussian_filter(imr, wid, <span class="number">0</span>, meanr)</span><br><span class="line">    <span class="comment"># 图像归一化处理</span></span><br><span class="line">    norml = iml - meanl</span><br><span class="line">    normr = imr - meanr</span><br><span class="line">    <span class="comment"># 计算不同视差</span></span><br><span class="line">    <span class="keyword">for</span> disp <span class="keyword">in</span> range(steps):</span><br><span class="line">        <span class="comment"># 将左边图像加到右边的图像上</span></span><br><span class="line">        filters.gaussian_filter(np.roll(norml, -disp - start) * normr, wid, <span class="number">0</span>, s)</span><br><span class="line">        filters.gaussian_filter(np.roll(norml, -disp - start) * np.roll(norml, -disp - start), wid, <span class="number">0</span>, s_l)</span><br><span class="line">        <span class="comment"># 和反归一化</span></span><br><span class="line">        filters.gaussian_filter(normr * normr, wid, <span class="number">0</span>, s_r)</span><br><span class="line">        <span class="comment"># 保存ncc的值</span></span><br><span class="line">        deepmaps[:, :, disp] = s / sqrt(s_l * s_r)</span><br><span class="line">    <span class="comment"># 为每个像素选取最佳深度</span></span><br><span class="line">    <span class="keyword">return</span> argmax(deepmaps, axis=<span class="number">2</span>)</span><br><span class="line">iml = np.array(Image.open(<span class="string">'../input/stereo-sample/im0.png'</span>).convert(<span class="string">'L'</span>), <span class="string">'f'</span>)</span><br><span class="line">imr = np.array(Image.open(<span class="string">'../input/stereo-sample/im1.png'</span>).convert(<span class="string">'L'</span>), <span class="string">'f'</span>)</span><br><span class="line"><span class="comment"># 开始偏移并设置步长</span></span><br><span class="line">steps = <span class="number">50</span></span><br><span class="line">start = <span class="number">4</span></span><br><span class="line"><span class="comment"># ncc的宽度</span></span><br><span class="line">wid = <span class="number">30</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, wid):</span><br><span class="line">    <span class="comment"># ncc方法</span></span><br><span class="line">    <span class="comment"># res_ncc = plane_sweep_ncc(iml, imr, start, steps, i)</span></span><br><span class="line">    <span class="comment"># 高斯方法</span></span><br><span class="line">    print(<span class="string">'宽度&#123;&#125;时的滤波结果！'</span>.format(i))</span><br><span class="line">    res_gaussian = plane_sweep_guess(iml, imr, start, steps, i)</span><br><span class="line">    <span class="comment"># imsave(r'.vscode\prml-myself\vision_ncc_out\&#123;&#125;.jpg'.format(i), res_ncc)</span></span><br><span class="line">    imsave(<span class="string">r'./&#123;&#125;.jpg'</span>.format(i), res_gaussian)</span><br></pre></td></tr></table></figure><h2 id="四、实验展示"><a href="#四、实验展示" class="headerlink" title="四、实验展示"></a>四、实验展示</h2><p>原始图像如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="E:\vscode_py\.vscode\prml-myself\im0.png" alt="im0.jpg" title>                </div>                <div class="image-caption">im0.jpg</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="E:\vscode_py\.vscode\prml-myself\im1.png" alt="im1.jpg" title>                </div>                <div class="image-caption">im1.jpg</div>            </figure><p>对不同窗口下的视差图如下（窗口值从1-30,50，100）</p><table><thead><tr><th style="text-align:center">窗口width</th><th style="text-align:center">ncc方法</th><th style="text-align:center">gaussian</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center"><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/10/23/HD9Qe1cETRkvNXC.jpg" alt="1.jpg](https://i.loli.net/2021/10/23/1pf6BJWuRZSnLTV.jpg)  | ![1.jpg" title>                </div>                <div class="image-caption">1.jpg](https://i.loli.net/2021/10/23/1pf6BJWuRZSnLTV.jpg)  | ![1.jpg</div>            </figure></td></tr><tr><td style="text-align:center">5</td><td style="text-align:center"><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/10/23/qk1ho4gsSZYEBAC.jpg" alt="5.jpg](https://i.loli.net/2021/10/23/PglouKOMWNjGkDp.jpg)  | ![5.jpg" title>                </div>                <div class="image-caption">5.jpg](https://i.loli.net/2021/10/23/PglouKOMWNjGkDp.jpg)  | ![5.jpg</div>            </figure></td></tr><tr><td style="text-align:center">30</td><td style="text-align:center"><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/10/23/Uf8wpEm4Isvi2aS.jpg" alt="29.jpg](https://i.loli.net/2021/10/23/GpSYfN156xAe23u.jpg) | ![29.jpg" title>                </div>                <div class="image-caption">29.jpg](https://i.loli.net/2021/10/23/GpSYfN156xAe23u.jpg) | ![29.jpg</div>            </figure></td></tr><tr><td style="text-align:center">50</td><td style="text-align:center"><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/10/23/WRT4EcmVMNoIKaO.jpg" alt="50.jpg](https://i.loli.net/2021/10/23/eKY8JXnmjfy1aEw.jpg) | ![50.jpg" title>                </div>                <div class="image-caption">50.jpg](https://i.loli.net/2021/10/23/eKY8JXnmjfy1aEw.jpg) | ![50.jpg</div>            </figure></td></tr><tr><td style="text-align:center">100</td><td style="text-align:center"><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/10/23/vTAsp3fC2mUdNYB.jpg" alt="100.jpg](https://i.loli.net/2021/10/23/j9kLR4YpTyPvmMJ.jpg) | ![100.jpg" title>                </div>                <div class="image-caption">100.jpg](https://i.loli.net/2021/10/23/j9kLR4YpTyPvmMJ.jpg) | ![100.jpg</div>            </figure></td></tr></tbody></table><h2 id="五、实验结果分析"><a href="#五、实验结果分析" class="headerlink" title="五、实验结果分析"></a>五、实验结果分析</h2><p>结果上来看，窗口值的大小改变对结果较大，wid值越小，颗粒感越大，匹配结果的区分度越低，并且成散粉分裂状；随着窗口值增大，匹配区分度逐渐清晰，精度也变高；当窗口值过大时，效果没有更好，反而暗区会越来越黑，匹配效果不是很好。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;立体视觉计算视差图-stereo-vision&quot;&gt;&lt;a href=&quot;#立体视觉计算视差图-stereo-vision&quot; class=&quot;headerlink&quot; title=&quot;立体视觉计算视差图 stereo vision&quot;&gt;&lt;/a&gt;立体视觉计算视差图 stereo </summary>
      
    
    
    
    <category term="计算机视觉" scheme="https://albert-5.github.io/blogs/categories/计算机视觉/"/>
    
    
    <category term="立体视觉" scheme="https://albert-5.github.io/blogs/tags/立体视觉/"/>
    
    <category term="视差图" scheme="https://albert-5.github.io/blogs/tags/视差图/"/>
    
  </entry>
  
  <entry>
    <title>深度优先和广度优先搜索算法</title>
    <link href="https://albert-5.github.io/blogs/70de7154/"/>
    <id>https://albert-5.github.io/blogs/70de7154/</id>
    <published>2021-10-21T14:57:13.000Z</published>
    <updated>2021-10-23T12:17:05.491Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/e33775cd8fc5" target="_blank" rel="noopener">参考学习内容</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/e33775cd8fc5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考学习内容&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="排序算法" scheme="https://albert-5.github.io/blogs/categories/排序算法/"/>
    
    
    <category term="深度优先搜索算法" scheme="https://albert-5.github.io/blogs/tags/深度优先搜索算法/"/>
    
    <category term="广度优先搜索算法" scheme="https://albert-5.github.io/blogs/tags/广度优先搜索算法/"/>
    
  </entry>
  
  <entry>
    <title>排序算法之快速排序</title>
    <link href="https://albert-5.github.io/blogs/77638675/"/>
    <id>https://albert-5.github.io/blogs/77638675/</id>
    <published>2021-10-18T07:27:47.000Z</published>
    <updated>2021-11-06T08:56:36.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序–一种使用D-amp-C的排序算法"><a href="#快速排序–一种使用D-amp-C的排序算法" class="headerlink" title="快速排序–一种使用D&amp;C的排序算法"></a>快速排序–一种使用<code>D&amp;C</code>的排序算法</h1><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><blockquote><p>快速排序是对冒泡排序算法的改进，基本思想是：选择一<code>基准元素</code>，以此将剩余元素中的小于该基准元素的值放在左边，大于该基准元素的值放在右边；然后再在左侧序列和右侧序列做同样的处理操作；以此类推，直至各个序列都剩余一个元素时，即排序完成。</p></blockquote><h2 id="算法实现步骤"><a href="#算法实现步骤" class="headerlink" title="算法实现步骤"></a>算法实现步骤</h2><ul><li>首先设定一基准值（pivot），通过该基准值将待排序序列分成左右两部分。</li><li>将小于或等于基准值的元素放在序列左边，将大于基准值的元素放在序列的右边。此时左边序列的元素都是小于基准值的，右边的元素都是大于基准值的，这个基准值就叫做<code>分区(partition)操作</code>。</li><li>此时，左边和右边的序列均可看作是新的序列，分别对左边、右边的序列进行基准值的选择，将序列再次分成两部分，同样的，左边部分的元素值小于基准值，右边部分的元素值大于基准值。</li><li>重复上述操作，通过<code>递归-recurive</code>将左侧部分排好序后，在递归对右边进行排序，当左右两个部分个数据排序完成后，整个序列再次组合加起来就形成了一个有序的序列了。<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(array) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = array[<span class="number">0</span>]</span><br><span class="line">        less = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &lt;= pivot]</span><br><span class="line">        greater = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; pivot]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> quicksort(less) + [pivot] + quicksort(greater)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(quicksort([<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">9</span>]))</span><br></pre></td></tr></table></figure></li></ul><h2 id="关于复杂度"><a href="#关于复杂度" class="headerlink" title="关于复杂度"></a>关于复杂度</h2><p>快速排序算法的性能高度依赖于基准值的选取。在上述代码中是将第一个元素作为基准值，且要处理的数据是有序的。它并不会检查数据的有序性，只会按部就班的进行排序操作。<br>最糟糕情况下，所有的元素都是已经排好序的，但此时算法仍会按照步骤进行排序，且选择的基准值是第一个元素，所花费的时间较长，复杂度为<code>O(n²)</code>；最好的情况是已排好序的序列，每次选取序列的中间位置元素作为基准值，这样复杂度大大减小，为<code>O(nlogn)</code>。</p><p><a href="https://visualgo.net/zh/sorting" target="_blank" rel="noopener">快速排序算法动图展示</a></p><div><strong>🚩推荐阅读</strong>（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）<ul><li><a href="https://albert-5.github.io/blogs/2f6ec745/">LDA线性判别分析</a></li><li><a href="https://albert-5.github.io/blogs/cb33e42c/">排序算法之选择排序</a></li><li><a href="https://albert-5.github.io/blogs/573d89ae/">豆瓣电影top250</a></li><li><a href="https://blog.naaln.com/2015/07/of-python-zen/">zen of python</a></li><li><a href="https://blog.naaln.com/2015/07/python-learning-notes-variable-objects-and-immutable-objects/">Python学习笔记——可变对象和不可变对象</a></li></ul></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;快速排序–一种使用D-amp-C的排序算法&quot;&gt;&lt;a href=&quot;#快速排序–一种使用D-amp-C的排序算法&quot; class=&quot;headerlink&quot; title=&quot;快速排序–一种使用D&amp;amp;C的排序算法&quot;&gt;&lt;/a&gt;快速排序–一种使用&lt;code&gt;D&amp;amp;C&lt;</summary>
      
    
    
    
    <category term="排序算法" scheme="https://albert-5.github.io/blogs/categories/排序算法/"/>
    
    
    <category term="python" scheme="https://albert-5.github.io/blogs/tags/python/"/>
    
    <category term="快速排序" scheme="https://albert-5.github.io/blogs/tags/快速排序/"/>
    
  </entry>
  
  <entry>
    <title>LDA线性判别分析</title>
    <link href="https://albert-5.github.io/blogs/2f6ec745/"/>
    <id>https://albert-5.github.io/blogs/2f6ec745/</id>
    <published>2021-10-16T13:13:38.000Z</published>
    <updated>2021-10-17T08:13:56.801Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LDA线性判别分析"><a href="#LDA线性判别分析" class="headerlink" title="LDA线性判别分析"></a>LDA线性判别分析</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>线性分类：</strong> 指存在一个<code>线性方程</code>可以把待分类样本分离开，或者用一个<code>超平面</code>将正负样本分开，表达式为<br>$$y=w^\mathrm T+b$$<br>所谓<code>超平面</code>即是区分样本点的一个决策面，在二维世界中，可以理解为一条直线，如一次函数。<br><strong>非线性分类：</strong> 指不存在一个线性分类能将样本分隔开，可以是一个曲面，也可以是多个超平面的组合。</p><h2 id="LDA思想"><a href="#LDA思想" class="headerlink" title="LDA思想"></a>LDA思想</h2><p><code>核心思想：类内小，类间大</code><br>线性判别分析（Linear Discrimination Analysis, LDA）是一种<code>监督学习</code>的线性降维方法，即每个样本都是由类别的输出。其主要思想是”投影后类内方差最小，类间方差最大“，我们知道，对于一组数据来说，均值决定了它的中心，方差则是决定了这组数据的离散程度，越大越离散，越小越集中。在二分类问题中，我们将样本点在低纬度上进行投影，投影后希望每一种类别数据的投影点尽可能的接近，两种类别的数据点的中心尽可能的远离。</p><h2 id="LDA算法的推导以及优化"><a href="#LDA算法的推导以及优化" class="headerlink" title="LDA算法的推导以及优化"></a>LDA算法的推导以及优化</h2><p>LDA原理，投影到低纬度上的空间中，使得投影后的点会形成按类别区分一簇一簇的分布情况，相同类别的点较为集中，不用类别的点相聚较远。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/10/16/hsrW1OvUPdJxi8q.png" alt="lda.png" title>                </div>                <div class="image-caption">lda.png</div>            </figure><br>那什么是线性判别分析呢？所谓线性判别分析，就是将样本数据点投影到直线上，直线函数的解析式又称为线性函数，通常的表达式为：<br>$$y=w^\mathrm T$$<br>其中$w$表示特征向量，$x$表示样本列向量，$y$表示投影后的样本列向量。<br>首先对两类样本进行考虑分析，然后在推广到多维问题。<br>给定数据集$D=^m_{i=1},y∈(0,1)$，$X_i,\mu_i,\Sigma_i$分别表示$i\in{0, 1}$类示例的集合、均值向量、协方差矩阵。若将数据投影到直线$w$上，则两类样本的中心在直线上的投影分别为$ w^\mathrm T\mu_0$和 $ w^\mathrm T \mu_1$；若将所以样本点都投影到之想爱你上，则两类样本的协方差矩阵分别为$w^\mathrm T\Sigma_0w$和$w^\mathrm T\Sigma_1w$。<br>想要使得<code>同类样本</code>的投影带你尽可能地接近，可以让同类样本点的投影点的协方差尽可能的小，即$w^\mathrm T\Sigma_0w$+$w^\mathrm T\Sigma_1w$尽可能小；而若想要<code>异类样本</code>的投影点尽可能的远离，可以让类中心带你的距离尽可能的大，即$||w^\mathrm T\mu_0-w^\mathrm T\mu_1||$尽可能大，同时考虑即可得到待优化的目标：<br>$$J=\frac{||w^\mathrm T\mu_0-w^\mathrm T\mu_1||}{w^\mathrm T\Sigma_0w+w^\mathrm T\Sigma_1w}=\frac{w^\mathrm T(\mu_0-\mu_1)(\mu_0-\mu_1)^\mathrm Tw}{w^\mathrm T(\Sigma_0 +\Sigma_1)w}$$<br>定义<code>类内散度矩阵（within-class scatter matrix）</code><br>$$<br>\begin{aligned}<br>S_w&amp;=\Sigma_0+\Sigma_1\<br>&amp;=\Sigma(x-\mu_0)(x-\mu_0)^\mathrm T+\Sigma(x-\mu_1)(x-\mu_1)^\mathrm T<br>\end{aligned}<br>$$<br>以及<code>类间散度矩阵（between-class scatter matrix）</code><br>$$<br>\begin{aligned}<br>S_b =(\mu_0-\mu_1)(\mu_0-\mu_1)^\mathrm T<br>\end{aligned}<br>$$<br>所以待优化目标为<br>$$<br>J=\frac{w^\mathrm TS_bw}{w^\mathrm TS_ww}<br>$$<br>这就是LDA欲最大化的目标表达，即$ S_b $和$S_w$的“广义瑞利商”（generalized Rayleigh quotient）.<br><strong>如何求取$w$呢？</strong><br>对于瑞利商来说，分子分母都是关于$w$的二次项，因此其解与$w$的长度无关，只与其方向有关，所以不妨令$w^\mathrm TS_ww=1$，则有：<br>$$<br>\begin{aligned}<br>\underset w min\quad -w^\mathrm TS_bw\<br>s.t.  \quad w^\mathrm TS_ww =1<br>\end{aligned}<br>$$<br>由<code>拉格朗日乘子法</code>得到等价式<br>$$S_bw=\lambda S_ww$$<br>其中，$\lambda$是拉格朗日乘子。注意到$S_bw$的方向为$(\mu_0-\mu_1)$，令<br>$$S_bw=\lambda (\mu_0-\mu_1)$$<br>即可得<br>$$w=S_w^{-1}(\mu_0-\mu_1)$$<br>$w$的最大值就是矩阵$S_w^{-1}S_b$的最大特征值。<br>至此，投影面即可得到。</p><h2 id="python实现以及结果展示"><a href="#python实现以及结果展示" class="headerlink" title="python实现以及结果展示"></a>python实现以及结果展示</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成两类随机样本</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createdata</span><span class="params">()</span>:</span></span><br><span class="line">    points1 = np.mat(np.random.random((<span class="number">10</span>, <span class="number">2</span>))*<span class="number">2</span>+<span class="number">4</span>)</span><br><span class="line">    points2 = np.mat(np.random.random((<span class="number">10</span>, <span class="number">2</span>))*<span class="number">3</span>+<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> points1, points2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算样本均值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_mean</span><span class="params">(samples, num)</span>:</span></span><br><span class="line">    ave = []</span><br><span class="line">    a, b = np.shape(samples[num])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(b):</span><br><span class="line">        n = np.sum(samples[num][:, i]) / a</span><br><span class="line">        ave.append(n)</span><br><span class="line">    <span class="keyword">return</span> np.array(ave)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算类内离散度和类间离散度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_swb</span><span class="params">(samples)</span>:</span></span><br><span class="line">    <span class="comment"># 获取样本的行列值</span></span><br><span class="line">    a, b = np.shape(samples[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 获取样本</span></span><br><span class="line">    points1, points2 = samples[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    <span class="comment"># 调用求均值函数</span></span><br><span class="line">    pointsmean1 = np.mat(cal_mean(points1, <span class="number">0</span>))</span><br><span class="line">    pointsmean2 = np.mat(cal_mean(points2, <span class="number">1</span>))</span><br><span class="line">    allpointsmean1 = (pointsmean1 + pointsmean2)/<span class="number">2</span></span><br><span class="line">    <span class="comment"># 先计算第一类类内离散矩阵</span></span><br><span class="line">    s1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(a):</span><br><span class="line">        s1 = s1 + (points1[i, :] - pointsmean1).T * (points1[i, :] - pointsmean1)</span><br><span class="line">    s2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(a):</span><br><span class="line">        s2 = s2 + (points2[i, :] - pointsmean2).T * (points2[i, :] - pointsmean2)</span><br><span class="line">    sw = (a*s1 + a*s2)/(a + a)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算类间离散矩阵</span></span><br><span class="line">    sb = (pointsmean1 - pointsmean2).T*(pointsmean1 - pointsmean2)</span><br><span class="line">    <span class="keyword">return</span> np.mat(sw), np.mat(sb), np.mat(allpointsmean1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">samples = createdata()</span><br><span class="line">plt.plot(samples[<span class="number">0</span>][:, <span class="number">0</span>], samples[<span class="number">0</span>][:, <span class="number">1</span>], <span class="string">'b.'</span>)</span><br><span class="line">plt.plot(samples[<span class="number">1</span>][:, <span class="number">0</span>], samples[<span class="number">1</span>][:, <span class="number">1</span>], <span class="string">'r.'</span>)</span><br><span class="line"><span class="string">""" 测试 """</span></span><br><span class="line">print(samples[<span class="number">0</span>].shape)</span><br><span class="line">pointsmean1 = cal_mean(samples, <span class="number">0</span>)</span><br><span class="line">pointsmean2 = cal_mean(samples, <span class="number">1</span>)</span><br><span class="line">print(pointsmean1)</span><br><span class="line">print(pointsmean2)</span><br><span class="line">sw, sb, allmean = cal_swb(samples)</span><br><span class="line"><span class="comment"># print(sw.shape)</span></span><br><span class="line"><span class="comment"># print(sb.shape)</span></span><br><span class="line"><span class="comment"># print(np.linalg.inv(sw))</span></span><br><span class="line"><span class="comment"># 求最大特征值对应的特征向量</span></span><br><span class="line">eigvalue, eigvector = np.linalg.eig(np.linalg.inv(sw).dot(sb))</span><br><span class="line">print(eigvalue)</span><br><span class="line">indexvec = np.argsort(-eigvalue)</span><br><span class="line">nlargestindex = indexvec[<span class="number">1</span>]</span><br><span class="line">print(nlargestindex)</span><br><span class="line"><span class="comment"># 最佳投影方向求得</span></span><br><span class="line">w = np.array(eigvector[nlargestindex])</span><br><span class="line"><span class="comment"># print(w)</span></span><br><span class="line"><span class="comment"># print(w[0][0])</span></span><br><span class="line"><span class="comment"># print(w.shape)</span></span><br><span class="line"><span class="comment"># 绘制散点图</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.scatter(np.array(samples[<span class="number">0</span>][:, <span class="number">0</span>]), np.array(samples[<span class="number">0</span>][:, <span class="number">1</span>]), c=<span class="string">'b'</span>, marker=<span class="string">'o'</span>)</span><br><span class="line">plt.scatter(np.array(samples[<span class="number">1</span>][:, <span class="number">0</span>]), np.array(samples[<span class="number">1</span>][:, <span class="number">1</span>]), c=<span class="string">'r'</span>, marker=<span class="string">'*'</span>)</span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, num=<span class="number">50</span>)</span><br><span class="line">y = w[<span class="number">0</span>][<span class="number">1</span>]/w[<span class="number">0</span>][<span class="number">0</span>]*x</span><br><span class="line">x1 = np.array((samples[<span class="number">0</span>][:, <span class="number">0</span>] + samples[<span class="number">0</span>][:, <span class="number">1</span>]*(w[<span class="number">0</span>][<span class="number">1</span>]/w[<span class="number">0</span>][<span class="number">0</span>]))/(<span class="number">1</span>+(w[<span class="number">0</span>][<span class="number">1</span>]/w[<span class="number">0</span>][<span class="number">0</span>])**<span class="number">2</span>))</span><br><span class="line">x2 = np.array((samples[<span class="number">1</span>][:, <span class="number">0</span>] + samples[<span class="number">1</span>][:, <span class="number">1</span>]*(w[<span class="number">0</span>][<span class="number">1</span>]/w[<span class="number">0</span>][<span class="number">0</span>]))/(<span class="number">1</span>+(w[<span class="number">0</span>][<span class="number">1</span>]/w[<span class="number">0</span>][<span class="number">0</span>])**<span class="number">2</span>))</span><br><span class="line">y1 = w[<span class="number">0</span>][<span class="number">1</span>]/w[<span class="number">0</span>][<span class="number">0</span>]*x1</span><br><span class="line">y2 = w[<span class="number">0</span>][<span class="number">1</span>]/w[<span class="number">0</span>][<span class="number">0</span>]*x2</span><br><span class="line">plt.scatter(x1, np.array(y1), c=<span class="string">'c'</span>, marker=<span class="string">'o'</span>)</span><br><span class="line">plt.scatter(x2, np.array(y2), c=<span class="string">'m'</span>, marker=<span class="string">'*'</span>)</span><br><span class="line">plt.plot(x, y, color=<span class="string">'r'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>结果展示如下<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/10/17/scHSJGl2yARfkLi.png" alt="课堂小作业2（2）.png" title>                </div>                <div class="image-caption">课堂小作业2（2）.png</div>            </figure></p><div><strong>🚩推荐阅读</strong>（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）<ul><li><a href="https://albert-5.github.io/blogs/77638675/">排序算法之快速排序</a></li><li><a href="https://albert-5.github.io/blogs/cb33e42c/">排序算法之选择排序</a></li><li><a href="https://albert-5.github.io/blogs/573d89ae/">豆瓣电影top250</a></li><li><a href="https://blog.naaln.com/2015/07/of-python-zen/">zen of python</a></li><li><a href="https://blog.naaln.com/2015/07/python-learning-notes-variable-objects-and-immutable-objects/">Python学习笔记——可变对象和不可变对象</a></li></ul></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LDA线性判别分析&quot;&gt;&lt;a href=&quot;#LDA线性判别分析&quot; class=&quot;headerlink&quot; title=&quot;LDA线性判别分析&quot;&gt;&lt;/a&gt;LDA线性判别分析&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="机器学习算法" scheme="https://albert-5.github.io/blogs/categories/机器学习算法/"/>
    
    
    <category term="LDA线性判别分析" scheme="https://albert-5.github.io/blogs/tags/LDA线性判别分析/"/>
    
    <category term="python" scheme="https://albert-5.github.io/blogs/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>排序算法之选择排序</title>
    <link href="https://albert-5.github.io/blogs/cb33e42c/"/>
    <id>https://albert-5.github.io/blogs/cb33e42c/</id>
    <published>2021-10-16T13:11:16.000Z</published>
    <updated>2021-10-16T13:23:41.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序算法之选择排序"><a href="#排序算法之选择排序" class="headerlink" title="排序算法之选择排序"></a>排序算法之选择排序</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数据在内存中的顺序是<code>连续的</code>，在使用时需要向计算机申请分配一定的内存空间，如果申请的空间一定，再加入新的数据时如果当前空间不足需要重新向计算机申请；同样，如果先前申请了大量的空间，但在使用过程中并没有被用到，则会造成<code>空间的浪费</code>。</p><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>数组的元素带编号，编号从<code>0</code>开始，这个位置叫做<code>索引</code>，故说：”元素a位于索引1处“，在元素读取和插入时有以下特征：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/10/16/SksICh92u8mqcbB.png" alt="数组和链表操作.png" title>                </div>                <div class="image-caption">数组和链表操作.png</div>            </figure></p><p>由于索引的存在，所以数组在读取数据时就有很快的速度；但在插入数据方面，需要将待插入位置的后面的所有数据向后移位，时间较长。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表中的元素可存储在内存的任何地方，其中的每个元素存放的都是<code>下一个元素的地址</code>，这样就能使一系列的内存地址串在一起。<br>删除操作时，链表是更好的选择，只需要修改前一个元素指向的地址。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><blockquote><p>算法思想：首先在未排序的队列中选择最小或者最大的元素，并存放到新队列的起始位置；然后再从剩余的元素中选择最小或者最大的一个，再将其放入到新队列的后面，以此重复操作。</p></blockquote><p>乐队歌曲作品如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/10/16/Nbvdlj3E9kgMO7u.png" alt="选择排序1.png" title>                </div>                <div class="image-caption">选择排序1.png</div>            </figure><br>对列表中的歌曲按照播放次数降序排列，进而将自己喜欢的音乐进行排序。方法即是遍历列表，找出播放次数最多的音乐，然后将其添加到新列表里。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/10/16/As7heDKRfj2TQGO.png" alt="选择排序2.png" title>                </div>                <div class="image-caption">选择排序2.png</div>            </figure><br>再次进行此操作，找出第二多的乐队。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/10/16/InMWE8trFp1KhHs.png" alt="选择排序3.png" title>                </div>                <div class="image-caption">选择排序3.png</div>            </figure><br>继续这样做，进而得到一个新的有序列表。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/10/16/eEtAUiDr8kcPgvT.png" alt="选择排序4.png" title>                </div>                <div class="image-caption">选择排序4.png</div>            </figure><br>时间复杂度上来看，对于列表里的n个元素，需要对每个元素都进行查看，所以时间复杂度为O（n)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findsmallest</span><span class="params">(arr)</span>:</span></span><br><span class="line">    smallest = arr[<span class="number">0</span>]</span><br><span class="line">    smallest_index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">        <span class="keyword">if</span> arr[i] &lt; smallest:</span><br><span class="line">            smallest = arr[i]</span><br><span class="line">            smallest_index = i</span><br><span class="line">    <span class="keyword">return</span> smallest_index</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectsort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    newarr = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">        smallest = findsmallest(arr)</span><br><span class="line">        newarr.append(arr.pop(smallest))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newarr</span><br><span class="line"></span><br><span class="line">print(selectsort([<span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">6</span>]))</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><div><strong>🚩推荐阅读</strong>（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）<ul><li><a href="https://albert-5.github.io/blogs/77638675/">排序算法之快速排序</a></li><li><a href="https://albert-5.github.io/blogs/2f6ec745/">LDA线性判别分析</a></li><li><a href="https://albert-5.github.io/blogs/573d89ae/">豆瓣电影top250</a></li><li><a href="https://blog.naaln.com/2015/07/of-python-zen/">zen of python</a></li><li><a href="https://blog.naaln.com/2015/07/python-learning-notes-variable-objects-and-immutable-objects/">Python学习笔记——可变对象和不可变对象</a></li></ul></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;排序算法之选择排序&quot;&gt;&lt;a href=&quot;#排序算法之选择排序&quot; class=&quot;headerlink&quot; title=&quot;排序算法之选择排序&quot;&gt;&lt;/a&gt;排序算法之选择排序&lt;/h1&gt;&lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="排序算法" scheme="https://albert-5.github.io/blogs/categories/排序算法/"/>
    
    
    <category term="python" scheme="https://albert-5.github.io/blogs/tags/python/"/>
    
    <category term="选择排序" scheme="https://albert-5.github.io/blogs/tags/选择排序/"/>
    
  </entry>
  
  <entry>
    <title>Camera-calibration</title>
    <link href="https://albert-5.github.io/blogs/4b5e616e/"/>
    <id>https://albert-5.github.io/blogs/4b5e616e/</id>
    <published>2021-10-09T07:20:19.000Z</published>
    <updated>2021-11-06T08:22:24.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相机标定"><a href="#相机标定" class="headerlink" title="相机标定"></a>相机标定</h1><h2 id="一、前提准备"><a href="#一、前提准备" class="headerlink" title="一、前提准备"></a>一、前提准备</h2><h3 id="1、伪硬件"><a href="#1、伪硬件" class="headerlink" title="1、伪硬件"></a>1、伪硬件</h3><table><thead><tr><th style="text-align:center">名称</th><th></th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td style="text-align:center">标定板8×10</td><td></td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">手机</td><td></td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">待标定照片</td><td></td><td style="text-align:center">12</td></tr><tr><td style="text-align:center">支架</td><td></td><td style="text-align:center">1</td></tr></tbody></table><p>手机固定在支架上，调整标定板位置，对其从不同角度进行拍照，所拍摄照片为11张。保存到文件夹后对其进行依次命名：*.jpg(如：1.jpg)</p><h3 id="2、软件"><a href="#2、软件" class="headerlink" title="2、软件"></a>2、软件</h3><p>&nbsp; 使用的编程语言：<code>python</code><br>&nbsp; 工具包：<code>opencv</code>, <code>numpy</code>, <code>glob</code></p><h2 id="二、寻找标定棋盘并进行标定"><a href="#二、寻找标定棋盘并进行标定" class="headerlink" title="二、寻找标定棋盘并进行标定"></a>二、寻找标定棋盘并进行标定</h2><h3 id="1、python-opencv-的方案"><a href="#1、python-opencv-的方案" class="headerlink" title="1、python + opencv 的方案"></a>1、<code>python + opencv</code> 的方案</h3><p> &nbsp;&nbsp;利用<code>opencv</code>寻找棋盘，所用到的函数如下：</p><ul><li>&nbsp;<code>cv2.TERM_CRITERIA_MAX_ITER | cv2.TERM_CRITERIA_EPS</code>：设置寻找亚像素点的终止迭代规则，前者为在指定迭代次数后停止算法，后者为要求的精度，在相机标定时才用的最大迭代次数为30次，最大精度为0.001。</li><li>&nbsp;<code>images = glob.glob(r&#39;G:\biaoding\*.jpg&#39;)</code>：glob函数能够返回所有匹配到的文件路径列表，用来读取待标定的棋盘图像。</li><li>&nbsp; <code>cv2.findChessboardCorners</code>：该函数用来找到棋盘，其返回值为角点，且会按一定顺序排列。</li><li>&nbsp; <code>cv2.cornerSubPix</code>：在上述找到角点的前提下寻找亚像素点，目的是为了增强检测角点的精度。</li><li>&nbsp; <code>cv2.drawChessboardCorners</code>：绘制找到的角点</li><li>&nbsp; <code>retv, mtx, dist, rvecs, tvecs = cv2.calibrateCamera</code>：相机标定函数，经过以上的计算以及找角点后进行相机标定，返回值为相机矩阵，畸变系数，旋转以及变换向量。</li></ul><h3 id="2、具体实施"><a href="#2、具体实施" class="headerlink" title="2、具体实施"></a>2、具体实施</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 采用循环找取亚像素点的参数，最大迭代次数采用30次，精度为0.001，两者同时满足时停止迭代</span></span><br><span class="line">criteria = (cv2.TERM_CRITERIA_MAX_ITER | cv2.TERM_CRITERIA_EPS, <span class="number">30</span>, <span class="number">0.001</span>)</span><br><span class="line"><span class="comment"># 所采用的棋盘规格8×10</span></span><br><span class="line">objp = np.zeros((<span class="number">7</span> * <span class="number">9</span>, <span class="number">3</span>), np.float32)</span><br><span class="line">objp[:, :<span class="number">2</span>] = np.mgrid[<span class="number">0</span>:<span class="number">9</span>, <span class="number">0</span>:<span class="number">7</span>].T.reshape(<span class="number">-1</span>, <span class="number">2</span>) <span class="comment"># 将世界坐标系建在标定板上，所有点的Z坐标全部为0</span></span><br><span class="line">obj_points = [] <span class="comment"># 坐标系中的三维点</span></span><br><span class="line">img_points = [] <span class="comment"># 图像平面中的二维点</span></span><br><span class="line"><span class="comment"># 从文件中依次读取照片</span></span><br><span class="line">images = glob.glob(<span class="string">r'G:\biaoding\*.jpg'</span>)</span><br><span class="line"><span class="keyword">for</span> fname <span class="keyword">in</span> images:</span><br><span class="line">  img = cv2.imread(fname)</span><br><span class="line">  cv2.namedWindow(<span class="string">'img'</span>, <span class="number">0</span>)</span><br><span class="line">  cv2.resizeWindow(<span class="string">'img'</span>, <span class="number">600</span>, <span class="number">600</span>)</span><br><span class="line">  cv2.imshow(<span class="string">'img'</span>,img)</span><br><span class="line">  cv2.waitKey()</span><br><span class="line">  <span class="comment"># cv2.destroyAllWindows()</span></span><br><span class="line">  gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">  size = gray.shape[::<span class="number">-1</span>]</span><br><span class="line">  <span class="comment"># print(size)</span></span><br><span class="line">  <span class="comment"># findchessboardcorner函数里寻找棋盘图的内角点</span></span><br><span class="line">  retv, corners = cv2.findChessboardCorners(gray, (<span class="number">7</span>, <span class="number">9</span>), <span class="literal">None</span>)</span><br><span class="line">  print(retv)</span><br><span class="line">  <span class="keyword">if</span> retv:</span><br><span class="line">    obj_points.append(objp)</span><br><span class="line">    <span class="comment"># 在原角点的基础上寻找亚像素角点</span></span><br><span class="line">    corners2 = cv2.cornerSubPix(gray, corners, (<span class="number">6</span>, <span class="number">6</span>), (<span class="number">-1</span>, <span class="number">-1</span>), criteria) </span><br><span class="line">    print(corners2)</span><br><span class="line">    <span class="keyword">if</span> [corners2]:</span><br><span class="line">      img_points.append(corners2)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      img_points.append(corners)</span><br><span class="line">    <span class="comment"># 绘制找到的角点</span></span><br><span class="line">    cv2.drawChessboardCorners(img, (<span class="number">7</span>, <span class="number">9</span>), corners, retv)</span><br><span class="line">    cv2.namedWindow(<span class="string">'img'</span>, <span class="number">0</span>)</span><br><span class="line">    cv2.resizeWindow(<span class="string">'img'</span>, <span class="number">600</span>, <span class="number">600</span>)</span><br><span class="line">    cv2.imshow(<span class="string">'img'</span>, img)</span><br><span class="line">    cv2.waitKey(<span class="number">20000</span>)</span><br></pre></td></tr></table></figure><p>  &nbsp; 待标定图像如下所示：<br>  <img src="https://i.loli.net/2021/10/09/SBd7WJi2rutq91Y.png" alt="标定图像.png"></p><p>找到棋牌并进行标定后的图片如下图所示：</p><table><thead><tr><th style="text-align:center">标定前</th><th></th><th style="text-align:center">标定后</th></tr></thead><tbody><tr><td style="text-align:center"><img src="https://i.loli.net/2021/10/09/ATCJK8ugYMjIZP6.png" alt="4.png"></td><td></td><td style="text-align:center"><img src="https://i.loli.net/2021/10/09/GyxJ2MjuhtoHRcC.png" alt="4（4）.png"></td></tr><tr><td style="text-align:center"><img src="https://i.loli.net/2021/10/09/2SZNi8FDw17EYMy.png" alt="5.png"></td><td></td><td style="text-align:center"><img src="https://i.loli.net/2021/10/09/2RsQx96kDOi4Ur3.png" alt="5（5）.png"></td></tr><tr><td style="text-align:center"><img src="https://i.loli.net/2021/10/09/7HoqQT4cuKAYSLF.png" alt="6.png"></td><td></td><td style="text-align:center"><img src="https://i.loli.net/2021/10/09/MkEvSUpTt7Zobjm.png" alt="6（6）.png"></td></tr></tbody></table><h3 id="3、相机相关参数"><a href="#3、相机相关参数" class="headerlink" title="3、相机相关参数"></a>3、相机相关参数</h3><p>相机矩阵Mtx：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1.86761254e+04</span> <span class="number">0.00000000e+00</span> <span class="number">4.09207342e+02</span>]</span><br><span class="line">[<span class="number">0.00000000e+00</span> <span class="number">1.77781655e+03</span> <span class="number">4.23180100e+02</span>]</span><br><span class="line">[<span class="number">0.00000000e+00</span> <span class="number">0.00000000e+00</span> <span class="number">1.00000000e+00</span>]]</span><br></pre></td></tr></table></figure><p>畸变系数dist:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dist:</span><br><span class="line"> [[<span class="number">-0.05541607</span> <span class="number">-0.17312714</span>  <span class="number">0.0776916</span>  <span class="number">-0.0767596</span>   <span class="number">0.07245637</span>]]</span><br></pre></td></tr></table></figure><p> 外参旋转向量:</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[ <span class="number">2.10761526</span>],</span><br><span class="line"> [<span class="number">-0.5901612</span> ],</span><br><span class="line"> [<span class="number">-2.10187724</span>]]</span><br></pre></td></tr></table></figure><p>外参平移向量:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[ <span class="number">1.32373017</span>],</span><br><span class="line"> [<span class="number">16.72137644</span>],</span><br><span class="line"> [<span class="number">57.99935184</span>]]</span><br></pre></td></tr></table></figure><div><strong>🚩推荐阅读</strong>（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）<ul><li><a href="https://albert-5.github.io/blogs/3ffaec4c/">关于opencv的配置问题</a></li></ul></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;相机标定&quot;&gt;&lt;a href=&quot;#相机标定&quot; class=&quot;headerlink&quot; title=&quot;相机标定&quot;&gt;&lt;/a&gt;相机标定&lt;/h1&gt;&lt;h2 id=&quot;一、前提准备&quot;&gt;&lt;a href=&quot;#一、前提准备&quot; class=&quot;headerlink&quot; title=&quot;一、前提准</summary>
      
    
    
    
    <category term="计算机视觉" scheme="https://albert-5.github.io/blogs/categories/计算机视觉/"/>
    
    
    <category term="相机标定" scheme="https://albert-5.github.io/blogs/tags/相机标定/"/>
    
    <category term="计算机视觉" scheme="https://albert-5.github.io/blogs/tags/计算机视觉/"/>
    
  </entry>
  
  <entry>
    <title>c语言短路求值</title>
    <link href="https://albert-5.github.io/blogs/78ff7d86/"/>
    <id>https://albert-5.github.io/blogs/78ff7d86/</id>
    <published>2021-09-23T15:31:29.000Z</published>
    <updated>2021-10-17T08:14:36.358Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>C语言学习过程遇到的重点内容记录</p></blockquote><h2 id="何为短路求值？"><a href="#何为短路求值？" class="headerlink" title="何为短路求值？"></a>何为短路求值？</h2><p>所谓短路求值，其实就是C语言逻辑操作符<code>&amp;&amp;</code>和<code>||</code>的特性，具体特性如下：</p><h3 id="amp-amp-逻辑与"><a href="#amp-amp-逻辑与" class="headerlink" title="&amp;&amp; 逻辑与"></a>&amp;&amp; 逻辑与</h3><p><strong>&amp;&amp;</strong> 逻辑操作符的左操作数总是首先进行求值, 如果它的值为真, 则继续计算右操作数的值, 然后执行与操作得到表达式结果; 如果它的值为假, 根据与操作 <strong>有假则假</strong> 的性质可以断定该表达式的值为假, 所以不再计算右操作数的值。</p><h3 id="逻辑或"><a href="#逻辑或" class="headerlink" title="|| 逻辑或"></a>|| 逻辑或</h3><p><strong>||</strong> 逻辑操作符的左操作数也是首先进行求值, 如果它的值为假, 则继续计算右操作数的值, 然后执行与操作得到表达式结果; 如果它的值为真, 根据或操作 <strong>有真则真</strong> 的性质可以断定该表达式的值为真, 所以不再计算右操作数的值。</p><h2 id="实际操作体验"><a href="#实际操作体验" class="headerlink" title="实际操作体验"></a>实际操作体验</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 短路求值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">    (a = <span class="number">0</span>) &amp;&amp; (b = <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d, b = %d\n"</span>, a, b);</span><br><span class="line">    </span><br><span class="line">    (a = <span class="number">1</span>) || (b = <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d, b = %d\n"</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上诉代码为简单的逻辑运算程序，我们大概会这样想，输出结果为<code>a = 0, b = 2</code>，<code>a = 1, b = 2</code>，但实际上并不是这样，具体输出如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Running] cd <span class="string">"e:\code2\.vscode\" &amp;&amp; gcc test.c -o test &amp;&amp; "</span>e:\code2\.vscode\<span class="string">"test</span></span><br><span class="line"><span class="string">a = 0, b = 1</span></span><br><span class="line"><span class="string">a = 1, b = 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Done] exited with code=0 in 0.657 seconds</span></span><br></pre></td></tr></table></figure><p>为什么呢？</p><p>这就是因为这两个逻辑操作符的特性问题，在<code>(a = 0) &amp;&amp; (b = 2);</code>中，由于<code>a = 0</code>，在逻辑与<code>&amp;&amp;</code>逻辑运算时为0，此时后面的程序不会再执行，也就是还是原来的值<code>b = 1</code>。</p><p>在<code>(a = 1) || (b = 2);</code>中，<code>a</code>的值是非零的，所以判断为<code>1</code>，此时后面的程序就不会在执行，这时的<code>b</code>的值为原来给定的值，即为<code>b = 1</code>。</p><div><strong>🚩推荐阅读</strong>（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）<ul><li><a href="https://albert-5.github.io/blogs/a91eaa72/">Git学习笔记</a></li></ul></div>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;C语言学习过程遇到的重点内容记录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;何为短路求值？&quot;&gt;&lt;a href=&quot;#何为短路求值？&quot; class=&quot;headerlink&quot; title=&quot;何为短路求值？&quot;&gt;&lt;/a&gt;何为短路求值？&lt;/h2&gt;&lt;p</summary>
      
    
    
    
    <category term="C语言" scheme="https://albert-5.github.io/blogs/categories/C语言/"/>
    
    
    <category term="学习笔记" scheme="https://albert-5.github.io/blogs/tags/学习笔记/"/>
    
    <category term="短路求值" scheme="https://albert-5.github.io/blogs/tags/短路求值/"/>
    
    <category term="C语言" scheme="https://albert-5.github.io/blogs/tags/C语言/"/>
    
  </entry>
  
  <entry>
    <title>关于opencv的配置问题</title>
    <link href="https://albert-5.github.io/blogs/3ffaec4c/"/>
    <id>https://albert-5.github.io/blogs/3ffaec4c/</id>
    <published>2021-09-22T12:51:13.000Z</published>
    <updated>2021-09-22T14:16:19.965Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近学习了计算机视觉的课程，准备用opencv来实现相机标定，但在<code>import cv2</code>时出现了一些问题，看了许多博客都没感觉有啥用。</p></blockquote><h2 id="问题一：vscode中import-cv2出现错误"><a href="#问题一：vscode中import-cv2出现错误" class="headerlink" title="问题一：vscode中import cv2出现错误"></a>问题一：vscode中<code>import cv2</code>出现错误</h2><p>在进行调用库文件<code>import cv2</code>时出现提示：<br><code>ImportError: No module named cv2</code><br>这种情况是属于没有下载<code>opencv</code>文件或者是安装位置不对导致的，所以去网站下了相关文件，具体链接如下：<a src="https://pypi.org/project/opencv-python/#files">opencv点击下载</a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/09/22/H5adfwCocASYu4t.jpg" alt="opencv.jpg" title>                </div>                <div class="image-caption">opencv.jpg</div>            </figure><br><code>注：</code>下载前确定好自己的<code>python版本</code>，版本不对的话还是会出现错误的。</p><p>紧接着，<code>ctrl + r</code>输入<code>cmd</code>，在命令提示窗内继续输入<code>pip install &lt;刚刚下载下来的文件路径&gt;</code></p><h2 id="问题二：pip-install出现问题"><a href="#问题二：pip-install出现问题" class="headerlink" title="问题二：pip install出现问题"></a>问题二：pip install出现问题</h2><p>上诉操作之后按道理来说是没有任何问题的，但偏偏还是出现了问题：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImportError: DLL load failed：找不到指定模块</span><br></pre></td></tr></table></figure></p><p> 这种情况错误产生的原因是<code>对应模块的文件不完善或者没有对应的模块</code>；<br> 解决方法下载相对应的模块，<a src="https://sourceforge.net/projects/opencvlibrary/files/">点击进入</a>。因为我用的是opencv-python，所以在下载完成后将python文件夹下的python38版本的opencv文件（<code>.pyd</code>结尾的）复制到python的安装目录<code>\python38\Lib\site-packages</code>下,并将其改名为<code>c2.pyd</code>。</p><h3 id="查找python安装路径的方法"><a href="#查找python安装路径的方法" class="headerlink" title="查找python安装路径的方法"></a>查找<code>python安装</code>路径的方法</h3><p> <code>win + r</code>输入<code>cmd</code>进入命令提示窗：<br> <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/09/22/5YKEVWfXxs1jClo.jpg" alt="cmd.jpg" title>                </div>                <div class="image-caption">cmd.jpg</div>            </figure><br> 然后，输入<code>python</code>进入到<code>python</code>交互环境，再输入以下命令：<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path</span><br></pre></td></tr></table></figure></p><p> <img src="https://i.loli.net/2021/09/22/5YKEVWfXxs1jClo.jpg" alt="cmd.jpg"><br> 这样就能看到相对应的<code>site-packages</code>文件夹。</p><h2 id="问题三：Defaulting-to-user-installation-because-normal-site-packages-is-not-writeable错误提示"><a href="#问题三：Defaulting-to-user-installation-because-normal-site-packages-is-not-writeable错误提示" class="headerlink" title="问题三：Defaulting to user installation because normal site-packages is not writeable错误提示"></a>问题三：Defaulting to user installation because normal site-packages is not writeable错误提示</h2><p> 从网上看了很多帖子，方法也都实验过了但都无济于事，先对一些方法做一些集锦：</p><ol><li>使用<code>user</code>权限<br><code>pip install --user &lt;package name&gt;</code></li><li>更改文件夹权限，让<code>packages</code>有权限写入；</li><li><p>找对<code>python</code>文件夹，确保将其加入到环境变量中，环境变量的查看以及操作方法如下：<br>在桌面右键<code>此电脑</code>，点击<code>属性</code>，选择<code>高级系统设置</code>,编辑并下列python文件夹加入到<code>path</code>，<code>...\python38\Scripts\</code>、<code>...\python38\</code>、<code>...\python38\Lib</code>。</p><p><code>注：</code>我的问题在第二步将<code>.pyd</code>文件添加到<code>site-packages</code>下就解决了。</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/09/22/rgEMcBPauhwIkpi.jpg" alt="测试结果.jpg" title>                </div>                <div class="image-caption">测试结果.jpg</div>            </figure><p>显示的图太大了，不太好展示。</p><center>完结！</center></li></ol><div><strong>🚩推荐阅读</strong>（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）<ul><li><a href="https://albert-5.github.io/blogs/4b5e616e/">Camera-calibration</a></li></ul></div>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近学习了计算机视觉的课程，准备用opencv来实现相机标定，但在&lt;code&gt;import cv2&lt;/code&gt;时出现了一些问题，看了许多博客都没感觉有啥用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;问题一：vscode中import-</summary>
      
    
    
    
    <category term="计算机视觉" scheme="https://albert-5.github.io/blogs/categories/计算机视觉/"/>
    
    
    <category term="计算机视觉" scheme="https://albert-5.github.io/blogs/tags/计算机视觉/"/>
    
    <category term="opencv" scheme="https://albert-5.github.io/blogs/tags/opencv/"/>
    
  </entry>
  
</feed>
