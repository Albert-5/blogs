{"meta":{"title":"Albert's Blog","subtitle":null,"description":null,"author":"Albert","url":"https://albert-5.github.io/blogs","root":"/blogs/"},"pages":[{"title":"Categories","date":"2021-09-13T05:34:16.000Z","updated":"2021-09-16T15:05:14.394Z","comments":false,"path":"categories/index.html","permalink":"https://albert-5.github.io/blogs/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2021-09-16T02:44:10.000Z","updated":"2021-09-16T15:04:53.345Z","comments":false,"path":"tags/index.html","permalink":"https://albert-5.github.io/blogs/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2021-09-16T02:45:25.000Z","updated":"2021-11-09T14:54:25.373Z","comments":true,"path":"about/index.html","permalink":"https://albert-5.github.io/blogs/about/index.html","excerpt":"","text":"@blockquote{ @card{ 🏛️关于小站🧐hi~，大家好，我是albert，欢迎你来到我的小站！准确的说，这是我的第一站，记录、分享是我建站的目的；关于小站Logo，那是一位科学家，有着卓越的能力，代表着前沿科学技术，同时呢，也代表着大国工匠精神，也是个人的一种理想吧！！ } } @blockquote{ @card{ ♓关于我 albert，英文名取自于Iron Man中的主人公 Robert Downey Jr.,同时也是聪明、勇敢的象征； 目前本科已毕业，是一名研究僧； 爱好：摄影、科幻、运动、旅游 世界这么大，想出国✈️转转… } @blockquote{ @card{ 🌐交流 音乐 📻 网易云音乐 🎵 QQ音乐 🎶 邮箱 📭 QQ邮箱 📮 Gmail 📧 赞赏 💰 支付宝 💵 微信 💶 Paypal 💲 我的相册 📷 相册 🎞️ 其他 ℹ️ 豆瓣小家 📇 简历 🏴󠁣󠁶󠁳󠁿 Resume 🏴󠁣󠁶󠁳󠁿 } } @blockquote{ @card{ 📣 友情链接 shanzei.top albert‘s old blog 学习进度 在线翻译、格式转化论文网站 🎟️ Send Name To Mars 📝更新日志@timeline{ 2019@item{ 4月22日弃用jekyll，改用hexo+githubpages搭建博客 } @item{ 4月23日完成博客基础配置，邮箱、微博、github··· } @item{ 4月24日增加支付打赏功能，目前仅支持支付宝、微信 } @item{ 4月25日添加鼠标点击特效 } @item{ 4月26日增加music、film、book、camera页面 } @item{ 4月27日在music页面下借助aplayer创建音乐歌单 } @item{ 4月28日seo优化，收录于Google } @item{ 4月29日增加文章置顶功能 } @item{ 5月1日新增图床，减少加载时间 } @item{ 5月2日利用HTML5 UP模板建立相册并分类化处理 } @item{ 5月17日在阿里云网站上购买域名albert-5.cn } @item{ 5月20日.cn 域名实名认证成功并顺利使用 } @item{ 5月21日为网站添加绿锁头，还是绿的好看;点击预览 } @item{ 6月2日增加网站管家&lt;小老婆&gt; } @item{ 11月10号更改侧边栏信息，更改底部信息 } 2020年@item{ 1-12月研究生备考！ } 2021年@item{ 4月22日成功上岸！ } @item{ 9月9日重回indigo！ } @item{ 9月10号修复toc不能跳转的bug } }"},{"title":"学习进度","date":"2021-09-23T03:59:52.000Z","updated":"2021-11-07T06:45:39.313Z","comments":true,"path":"学习进度/index.html","permalink":"https://albert-5.github.io/blogs/学习进度/index.html","excerpt":"","text":"📝学习进度@timeline{ 2021@item{ 9月23日重温C语言 } @item{ 10月13日电子书集 } @item{ 10月14日算法图解学习 } @item{ 11月7日算法图解完结 } @item{ 11月8日python入门到入土 } }"}],"posts":[{"title":"hello_world","slug":"hello-world-1","date":"2022-03-09T10:54:11.000Z","updated":"2022-03-09T10:54:29.248Z","comments":true,"path":"f73eae91/","link":"","permalink":"https://albert-5.github.io/blogs/f73eae91/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-03-09T10:47:07.110Z","updated":"2021-09-16T13:30:22.517Z","comments":true,"path":"4a17b156/","link":"","permalink":"https://albert-5.github.io/blogs/4a17b156/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"你好，世界","slug":"你好，世界","permalink":"https://albert-5.github.io/blogs/categories/你好，世界/"}],"tags":[{"name":"hello_world","slug":"hello-world","permalink":"https://albert-5.github.io/blogs/tags/hello-world/"}]},{"title":"Linux学习笔记六","slug":"Linux学习笔记六","date":"2022-02-13T02:22:46.000Z","updated":"2022-02-14T07:01:00.456Z","comments":true,"path":"fc88e170/","link":"","permalink":"https://albert-5.github.io/blogs/fc88e170/","excerpt":"","text":"Linux学习笔记六Linux任务计划crontab周期性的清理/tmp、周期性的去备份一次数据库、周期性的分析日志等，因此需要利用Linux系统的计划工具–crontab（用于设置周期性被执行的命令）。 crontab命令从输入设备读取指令，并将其存放于crontab文件中，以供之后读取和执行。通常情况下，crontab存储的指令被守护进程激活，crond为其守护进程，crond常常在后台运行，每一分钟会检查一次是否由预定的作业需要执行。 crontab指令格式： # Example of job definition: #.—————- minute (0 - 59) #| .————- hour (0 - 23) #| | .———- day of month (1 - 31) #| | | .——- month (1 - 12) OR jan,feb,mar,apr … #| | | | .—- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat #| | | | | # * user-name command to be executed crontab的使用 1crontab -e 以上命令来添加一个计划任务。 然后通过以下命令来查看添加了哪些内容： 1crontab -l 确保cron是否成功在后台启动的方法： 123ps aux | grep cron# orpgrep cron 在不需要这个任务时可以使用以下命令来删除一个任务： 1crontab -r 命令执行顺序控制和管道顺序执行多条命令安装软件 使用apt-get安装软件，然后安装完成后立即运行安装的软件或命令工具，如下： 123sudo apt-get updatesudo apt-get install some-toolsome-tool 但要是一次性输入完，让它自己去依次执行各个命令，简单的顺序执行可以使用;来完成： 1sudo apt-get update;sudo apt-get install some-tool;some-tool 有选择的执行命令即上一条命令执行成功才继续下一条，或者不成功又该做出其它处理。例如： 1which cowsay&gt;/dev/null &amp;&amp; cowsay -f head-in ohch~ 上面的&amp;&amp;就是用来实现选择性执行的，它表示如果前面的命令执行结果（不是表示终端输出的内容而是表示命令执行状态的结果）返回0则执行后面的，否则不执行，可以从$?环境变量获取上一次命令的返回结果。 管道管道是一种通信机制，通常用于进程间的通信（也可以通过socket进行网络通信），它表现出来的形式就是将前面每一个进程的输出（stdout）直接作为下一个进程的输入（stdin）。 其中管道又分为匿名管道和具名管道。匿名管道在使用时通常是用分隔符|表示。 查看/etc目录下有哪些文件和目录，使用ls来查看： 1ls -al /etc 可是内容太多，屏幕并不能完全显示，这时就需要使用滚动条或者快捷键滚动窗口来查看，但也可以使用管道： 1ls -al /etc | less 通过管道将前一个命令(ls)的输出作为下一个命令(less)的输入，然后就可以一行一行的看。 cut命令打印输出文件打印 /etc/passwd 文件中以 : 为分隔符的第 1 个字段和第 6 个字段分别表示用户名和其家目录： 1cut /etc/passwd -d ':' -f 1,6 打印 /etc/passwd 文件中每一行的前 N 个字符： 12345678# 前五个（包含第五个）cut /etc/passwd -c -5# 前五个之后的（包含第五个）cut /etc/passwd -c 5-# 第五个cut /etc/passwd -c 5# 2 到 5 之间的（包含第五个）cut /etc/passwd -c 2-5 grep命令–查找一般形式为： 1grep [命令选项]... 用于匹配的表达式 [文件] 例如： 1grep -rnI \"shiyanlou\" ~ -r参数表示递归搜索子目录中的文件，-n表示打印匹配项行号，-I表示忽略二进制文件。 wc命令该命令用于统计并输出一个文件中的行、单词和字节的数目。 12345678910# 行数wc -l /etc/passwd# 单词数wc -w /etc/passwd# 字节数wc -c /etc/passwd# 字符数wc -m /etc/passwd# 最长行字节数wc -L /etc/passwd sort排序该功能是将输入按照一定方式排序，然后再输出，它支持的排序有按字典排序、数字排序、按月份排序、随机排序、反转排序和指定特定字段进行排序。 默认为字典排序： 1cat /etc/passwd | sort 反转排序： 1cat /etc/passwd | sort -r 按特定字段排序： 1cat /etc/passwd | sort -t':' -k 3 -t参数用于指定字段的分隔符；-k字段号用于指定对哪一个字段进行排序。","categories":[{"name":"Linux学习笔记","slug":"Linux学习笔记","permalink":"https://albert-5.github.io/blogs/categories/Linux学习笔记/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://albert-5.github.io/blogs/tags/学习笔记/"},{"name":"Linux","slug":"Linux","permalink":"https://albert-5.github.io/blogs/tags/Linux/"}]},{"title":"Linux学习笔记五","slug":"Linux学习笔记五","date":"2022-02-13T02:21:27.000Z","updated":"2022-02-14T07:01:00.458Z","comments":true,"path":"fa912973/","link":"","permalink":"https://albert-5.github.io/blogs/fa912973/","excerpt":"","text":"Linux学习笔记五文件系统操作与磁盘管理查看磁盘和目录的容量使用df命令查看磁盘的容量 12dfdf -h 便于人们阅读 在物理主机中，物理主机上的 /dev/sda2 是对应着主机硬盘的分区，后面的数字表示分区号，数字前面的字母 a 表示第几块硬盘（也可能是可移动磁盘），你如果主机上有多块硬盘则可能还会出现 /dev/sdb，/dev/sdc 这些磁盘设备都会在 /dev 目录下以文件的存在形式。 使用du命令查看目录的容量 1234567891011dudu -h# -d参数查看目录的深度# 只查看一级目录的信息du -h -d 0 ~# 查看二级目录du -h -d 1 ~# 同 --all 显示目录中所有文件的大小du -a# 同 --summarize 仅显示总和，只列出最后加总的和du -s 创建虚拟磁盘dd命令：用于转换和复制文件，Linux思想：一切皆文件，而且硬件的设备驱动（如硬盘）和特殊设备文件（如/dev/zero和/dev/random）都像普通文件一样，只是在各自的驱动程序中实现了对应的功能，这样dd命令也可以用在备份硬件的引导扇区，获取一定数量的随机数据或空数据等。命令格式为选项=值，默认情况下从标准输入中读取，并写入到标准输出中，但可以用选项if(input file)和of(output file)改变。 1234# 输出到文件dd of=test bs=10 count=1# 输出到标准输出dd if=/dev/stdin of=/dev/stdout bs=10 count=1 上述中，bs表示block size，用于指定块大小，缺省单位为Bytes，也可以指定为K M G；count用于指定块数量 使用dd命令创建虚拟镜像文件 从/dev/zero设备创建一个容量为256M的空文件 12dd if=/dev/zero of=virtual.img bs=1M count=256du -h virtural.img 然后将此文件格式化（写入文件系统）。 使用mkfs命令格式化磁盘 将虚拟磁盘镜像格式化为ext4文件系统。 1sudo mkfs.ext4 virtual.img 使用mount命令挂载磁盘到目录树 用户在Linux/UNIX的机器上打开一个文件之前，包含该文件的文件系统必须先进行挂载的操作，此时用户要对该文件系统执行mount指令来进行挂载。该指令通常是使用在USB或其他可移除存储设备上，而根目录则需要始终保持挂载的状态 查看下主机已经挂载的文件系统 1sudo mount 其中命令格式为：mount [option][source][directory] 挂载创建的虚拟硬盘镜像到指定目录 123mount -o loop -t ext4 virtual.img /指定目录# 以只读方式挂载mount -o loop --ro virtual.img /指定目录 使用umount命令卸载已经挂载的磁盘 1sudo umount /目录 使用fdisk为磁盘分区 1234# 查看硬盘分区表信息sudo fdisk -l# 进入磁盘分区模式sudo fdisk virtual.img 轻松一下cowsay在终端里以一种动物说话的方式打印输出一段话 1234567891011sudo apt updatesudo apt install -y cowsaycowsay hello world # 默认是牛# 加上‘-l’参数打印所有支持的动物种类cowsay -l# 使用'-f'参数选择动物种类cowsay -f elephant hello world# 安装fortune-zhsudo apt-get fortune-zh/user/games/fortune | cowsay -f da","categories":[{"name":"Linux学习笔记","slug":"Linux学习笔记","permalink":"https://albert-5.github.io/blogs/categories/Linux学习笔记/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://albert-5.github.io/blogs/tags/学习笔记/"},{"name":"Linux","slug":"Linux","permalink":"https://albert-5.github.io/blogs/tags/Linux/"}]},{"title":"Linux学习笔记四","slug":"Linux学习笔记四","date":"2022-02-07T03:19:49.000Z","updated":"2022-02-07T03:26:42.910Z","comments":true,"path":"e7734b36/","link":"","permalink":"https://albert-5.github.io/blogs/e7734b36/","excerpt":"","text":"Linux学习笔记四文件打包常见的文件压缩包文件格式，windows上常见的有*.zip、*.7z。但Linux上要有更多，如下： 文件后缀名 说明 *.zip zip 程序打包压缩的文件 *.rar rar 程序压缩的文件 *.7z 7zip 程序压缩的文件 *.tar tar 程序打包，未压缩的文件 *.gz gzip 程序（GNU zip）压缩的文件 *.xz xz 程序压缩的文件 *.bz2 bzip2 程序压缩的文件 *.tar.gz tar 打包，gzip 程序压缩的文件 *.tar.xz tar 打包，xz 程序压缩的文件 *tar.bz2 tar 打包，bzip2 程序压缩的文件 *.tar.7z tar 打包，7z 程序压缩的文件 使用zip打包文件夹 1234cd 目录zip -p -r -o fiel.zip 路径du -h file.zipfile file.zip 其中，-r参数表示递归打包包含子目录的全部内容，-q参数表示为安静模式，即不向屏幕输出信息，-o表示输出文件，需在其后紧跟打包输出文件名。后面使用du命令查看打包后文件的大小。 设置压缩级别为9和1（9最大，1最小），重新打包。 12zip -r -9 -q -o filename.zipzip -r -1 -q -o filename.zip 1表示最快压缩但体积大，9表示体积最小但耗时最久。 在使用du命令分别查看默认压缩级别、最低、最高压缩级别以及未压缩的文件的大小。 1du -h -d 0 *.zip ~ | sort 注 -h全称–human-reachable，易人们读；-d全称为–max-depth 创建加密zip包 使用-e参数可以创建加密压缩包 1zip -r -e -o file.zip 待压缩文件目录 但如果想让在Linux创建的zip压缩包文件在Windows上解压后没有任何问题，需要使用以下命令： 1zip -r -l -o file.zip 待压缩文件目录 使用unzip解压到当前目录 1unzip file.zip 使用安静模式，将文件解压到指定目录： 1unzip -q file.zip -d ziptest 但如果只想查看压缩包的内容可以使用-l参数： 1unzip -l file.zip 文件压缩文件打包工具tar创建一个tar包： 12cd 目录tar -P -cf file.tar 文件路径 其中，-p保留绝对路径符，-c表示创建一个tar包文件，-f用于指定创建的文件名，文件名必须紧跟在-f之后。 解包一个文件（-x参数）到指定路径的已存在目录（-C参数）： 12mkdir tardirtar -xf file.tar -C tardir 只查看不解包文件-t参数 1tar -tf file.tar 保留文件属性和跟随链接 1tar -cpf etc.tar etc 冬季火炉 12sudo apt-get install libaa-binaafire","categories":[{"name":"Linux学习笔记","slug":"Linux学习笔记","permalink":"https://albert-5.github.io/blogs/categories/Linux学习笔记/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://albert-5.github.io/blogs/tags/学习笔记/"},{"name":"Linux","slug":"Linux","permalink":"https://albert-5.github.io/blogs/tags/Linux/"}]},{"title":"Linux学习笔记三","slug":"Linux学习笔记三","date":"2022-02-07T03:19:23.000Z","updated":"2022-02-07T03:26:42.908Z","comments":true,"path":"aba12728/","link":"","permalink":"https://albert-5.github.io/blogs/aba12728/","excerpt":"","text":"Linux学习笔记三环境变量变量准确的说是shell变量，就是计算机中用于记录一个值的符号，而这些符号将用于不同的运算处理中。通常变量与值都是一一对应的关系，可以通过表达式读取它的值并赋值给其他变量，也可以直接指定数值赋值给任意变量。 使用declare命令创建一个变量名为temp的变量。 1declare temp 预声明而已 使用=赋值运算符将变量temp进行赋值，shell中的赋值操作，=两边不能有空格 1234# 正确的赋值temp=nihao# 错误的赋值temp = nihao 读取变量的值，使用echo和$符号。（$符号用于表示引用一个变量的值） 1echo $temp 变量类型有三种： 当前shell进程私有用户自定义变量 shell本身内建的变量 从自定义变量导出的环境变量 与上述相关的命令为：set、env、export set：显示当前shell所有变量，包括其内建环境变量，用户自定义变量以及导出的环境变量； env：显示与当前用户相关的环境变量，还可以让命令在指定环境中运行； export：显示从shell中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量。 永久生效 永久的：需要修改配置文件，变量永久生效 临时的：使用export命令行声明即可，变量在关闭shell时失效。 注两个文件/etc/bashrc和/etc/profile分别存放的是shell变量和环境变量。 命令的查找路径与顺序查看PATH环境变量的内容 1echo $PATH 创建一个shell脚本文件，可以使用gedit,vim,sublime等工具编辑 123cd mydirtouch hello_shell.shgedit hello_shell.sh 在脚本中添加内容 1234567#!/bin/bashfor ((i=0; i&lt;10; i++));do echo &quot;hello shell&quot;doneexit 0 为文件添加可执行权限，否则执行时会报错。 1chmod 755 hello_shell.sh 执行脚本即可 12cd sh_filedir./hello_shell.sh 创建C语言的hello world程序 1gedit hello_world.c 添加一下程序： 1234567#include &lt;stdio.h&gt;int main(void)&#123; printf(\"hello world!\\n\"); return 0;&#125; 保存后使用gcc生成可执行文件： 1gcc -o hello_world hello_world.c 变量删除 使用unset命令删除一个环境变量 1unset mypath 文件查找与搜索有关的命令有：whereis、which、find、locate whereis简单快速12whereis whowhereis find whereis只能搜索二进制文件（-b），man帮助文件（-m）和源代码文件（-s）. locate快且全 使用locate命令查找文件也不会遍历硬盘，它通过查询/var/lib/mlocate/mlocate.db数据库来检索信息。不过这个数据库也不是实时更新的，系统会使用定时任务每天自动执行updatedb命令来更新数据库。 12345sudo apt-get updatesudo apt-get install locatesudo updatedblocate /etc/sh 查找`/etc`下所有以sh开头的文件 查找某目录下的所有图片： 1locate /dir/*.jpg which小而精 which本身是shell内建的一个命令，使用该命令来确定是否安装了某个指定的程序，因为它只从PATH环境变量指定的路径去搜索命令并且返回第一个搜索到的结果 123which manwhich nginxwhich ping find精而细 find不仅可以通过文件类型、文件名进行查找而且还可以根据文件的属性进行搜索，比如文件的时间戳和文件的权限等。 命令格式为：find [path][option][action] 与时间有关的命令参数： -atime：最后访问时间 -ctime：最后修改文件内容的时间 -mtime：最后修改文件属性的时间 -mtime n：n为数字，表示为在n天之前的一天之内修改过的文件、 -mtime +n：列出在n天之前被修改过的文件 mtime -n：列出在n天之内被修改过的文件 newer file：file作为一个已经存在的文件，列出比file还要新的文件名 实现黑客帝国里的数字雨 123sudo apt-get updatesudo apt-get install cmatrixcmatrix # 运行","categories":[{"name":"Linux学习笔记","slug":"Linux学习笔记","permalink":"https://albert-5.github.io/blogs/categories/Linux学习笔记/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://albert-5.github.io/blogs/tags/学习笔记/"},{"name":"Linux","slug":"Linux","permalink":"https://albert-5.github.io/blogs/tags/Linux/"}]},{"title":"Linux学习笔记二","slug":"Linux学习笔记二","date":"2022-02-07T02:42:50.000Z","updated":"2022-02-07T03:26:42.905Z","comments":true,"path":"e9fdb125/","link":"","permalink":"https://albert-5.github.io/blogs/e9fdb125/","excerpt":"","text":"Linux 学习笔记二Linux文件组织目录结构Linux的文件目录是树形结构的形式，每个目录不仅能使用本地磁盘分区的文件系统，也可以使用网络上的文件系统。比如可以利用网络文件系统（Network File System，NFS)服务器载入某特定目录。 FHS标准： FHS（Filesystem Hierarchy Standard）中文全称为文件系统层次结构标准，它定义了两层规范，一，/下面的各个目录应该要放什么文件数据，例如/etc应该放置文件，/bin和/sbin则该放置可执行文件。二，针对/usr及/var这两个目录来定义。 1tree / 如果提示command not found就先进行安装， 12sudo apt-get updatesudo apt-get install tree 相对路径和绝对路径路径就是想去哪的路线，使用cd命令可以切换目录，在Linux里面使用，表示当前目录；..表示上一级目录（以.开头的文件都是隐藏文件，可以使用ls -a命令查看隐藏文件）；-表示上一次所在目录；～baishio 文件的创建、移动、复制、重命名和编辑新建文件 1touch filename 新建目录 使用mkdir命令可以创建一个空目录，也可以同时指定创建目录的权限属性。 1mkdir mydir 也可以使用-p参数，同时多级目录。 1mkdir -p father/son/grandson 文件的复制 使用cp命令可以复制一个文件到指定的目录中。 1cp filename mydir 目录的复制 直接使用cp命令复制一个目录会发生错误，所以需要天界-r或-R参数，表示递归复制。 删除文件 使用rm命令删除一个文件： 1rm test 但如果想要删除一些为只读权限的文件，直接使用rm删除会显示一个提示：是否删除有写保护的普通文件？要想忽略这个提示，直接删除文件，就需要使用-f参数强制删除。 1rm -f test 删除目录 跟复制目录一样，要删除一个目录一样 也需要加上参数-r或-R 12rm -r family遇到权限不足删除不了的目录可以和删除文件一样加上`-f`参数 文件的移动 使用mv（move or rename files）命令移动文件（剪切）。命令格式为mv 源文件 目的目录 重命名文件 mv命令除了能移动文件外，还能给文件重命名。命令格式为mv 旧的文件名 新的文件名 批量操作下，当前命令就有点力不从心了，这时候可以使用rename来实现。rename命令并不是内置命令，若提示无命令可以使用sudo apt-get install rename命令来安装。 123touch file&#123;1..5&#125;.txtrename 's/\\.txt/\\.c\\' *.txtrename 'y/a-z/A-Z/' *.c rename是先将第二个参数的通配符匹配所有后缀为.txt的文件，然后使用第一个参数提供的正则表达式将匹配的这些文件的.txt后缀替换为.c。 使用cat tac和nl命令查看文件 前两个文件都是用来打印文件内容到标准输出，其中cat为正序显示，tac为倒序显示 123cat passwdcat -n passwd 带有行号cat -nl passwd 添加行号并打印 使用more和less命令分页查看文件 more和less是用来阅读一个文件的内容的，比如man手册内部就是使用less来显示内容的。其中，more命令比较简单，只能向一个方向滚动，而less为基于more和vi开发的。 使用more命令打开文件： 1more filename 打开后默认只显示一屏的内容，终端底部会显示当前阅读的进度，可以使用Enter键向下滚动一行，使用Space键向下滚动一屏，按下h显示帮助，q退出。 使用head和tail命令查看文件 该命令是查看文件的头几行，默认是10行；也可以使用-n参数，后面紧跟行数。 12tail filenametail -n 1 filename 只查看一行 查看文件类型file 1file filename 嘻哈一下 开天眼方法 12xeyesnohup xeyes &amp;","categories":[{"name":"Linux学习笔记","slug":"Linux学习笔记","permalink":"https://albert-5.github.io/blogs/categories/Linux学习笔记/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://albert-5.github.io/blogs/tags/学习笔记/"},{"name":"Linux","slug":"Linux","permalink":"https://albert-5.github.io/blogs/tags/Linux/"}]},{"title":"Linux学习笔记一","slug":"Linux学习笔记一","date":"2022-02-07T02:40:09.000Z","updated":"2022-02-07T03:26:42.914Z","comments":true,"path":"d27d9f8c/","link":"","permalink":"https://albert-5.github.io/blogs/d27d9f8c/","excerpt":"","text":"Linux学习笔记一基础Linux基础Ctrl相关操作常用按键 按键 作用 Ctrl D 键盘输入结束或退出终端 Ctrl S 暂停当前程序，暂停后按下任意键恢复运行 Ctrl Z 将当前程序放到后台运行，恢复到前台为命令fg Ctrl a 将光标移至输入行头，相当于Home键 Ctrl e 将光标移至行末，相当于End键 Ctrl k 删除从光标所在位置到行末 Alt Backspace 向前删除一个词 Shift PgUp 将终端显示向上滚动 Shift PgDn 将终端显示向下滚动 Ctrl C 终止程序运行 历史输入命令使用键盘键盘上的 ↑ 就能恢复之前输入过的命令。 使用通配符通配符是一种特殊语句，主要由星号（*）和问号（？），用来对字符串进行模糊匹配（比如文件名或参数名）。在查找文件夹时，可以使用它来代替一个或多个真正字符；在不知道真正字符或者懒得输入完整名字时，通常可以使用通配符代替一个或多个真正字符。 注：终端里输入的通配符是由 Shell 处理的，并不是由所涉及的命令语句处理的。 在具体操作时，进入到某个目录中： 1cd 目录 然后使用touch命令创建文件，后缀为.txt 1touch file1.txt file2.txt 但假若过了很长时间，已经忘记了这两个文件，现在又想在一大堆文件中找到这两个文件，就可以使用通配符来寻找。 1ls *.txt 不仅如此，在创建文件时也可以使用通配符来批量操作，比如： 1touch file_&#123;1..5&#125;.txt Shell常用通配符 字符 含义 * 匹配0或多个字符 ？ 匹配任意一个字符 [list] 匹配list中的任意单一字符 [^list] 匹配除list中的任意单一字符以外的字符 [c1-c2] 匹配c1-c2中的任意单一字符，如[0-9] [a-z] {string1, string2, …….} 匹配string1或string2（或更多）其一字符串 {c1..c2} 匹配c1-c2中全部字符，如{1..10} 在命令行中使用帮助在Linux环境中，使用man命令，全称为Manual pages，这是UNIX操作系统中在线软件文档的一种普遍的形式，内容包括计算机程序（包括库和系统调用）、正式的标准和惯例。甚至是抽象的概念。 1man &lt;command_name&gt; 一个有趣的例子一个可以输出图形字符的命令banner，具体操作如下： 首先使用如下命令安装： 123456sudo apt-get updatesudo apt-get install sysvbannerbanner love更改字体操作，使用默认已经安装的一个命令`printerbanner`printerbanner -w 50 A 用户以及权限管理 Linux是一个可以实现多用户登录的操作系统，多用户可共享一些主机资源，但分别有自己的用户空间，用于存放各自的文件。实际上这些用户的文件都是存放在同一个物理磁盘上甚至是同一个逻辑分区或者目录上的，由于Linux的用户管理和权限机制，不同的用户不可以轻易的查看或修改彼此的文件。 在终端输入命令 ： 123who am i或者who mom likes 输出的第一列表表示打开当前伪终端的用户的用户名（要查看当前登录用户的用户名，去掉空格直接使用whoami)，第二列的pts/0中的pts表示伪终端，所谓的伪是相对于/dev/tty设备而言的，第三列则表示当前伪终端的启动时间。 但要注意的是有些环境中使用who am i或who mom likes并不会输出任何内容，因为当前的SHELL不是登录时的SHELL，并没有用户与who的stdin相关联，因此不会输出任何内容。只需要在打开一个登录SHELL的终端如Tmux或者通过ssh登录到本机，再在新的终端里执行命令。 who命令其他常用参数 参数 含义 -a 打印能打印的内容 -d 打印死掉的进程 -m 同am i,mom likes -q 打印当前登录用户以及用户名 -u 打印当前登录用户登录信息 -r 打印运行等级 创建用户在Linux系统里，root账户拥有整个系统最高的权限，比如新建和添加用户。 一般登录系统时都是以普通账户的身份登录的，要创建用户需用root权限，就要用到sudo命令。前提是：一，要知道当前登录用户的密码；二，当前用户必须在sudo用户组。 su &lt;user&gt;: 切换到用户组，输入时需要输入目标用户的密码 sudo &lt;cmd&gt;: 以特权级别运行cmd命令，需要当前用户属于sudo用户组，且需要输入当前用户的密码 su - &lt;user&gt;: 命令也是切换用户，但是同时用户的环境变量和工作目录也会跟着改变目标用户所对应的。 操作如下 1sudo adduser name 根据提示来设置用户名密码以及有关操作。而且该命令不但可以添加用户到系统，同时也会默认为新用户在/home目录下创建一个工作目录： 1ls /home 该命令可以查看到当前用户状态，现在已经创建好一个用户，并且可以使用创建的用户登录，使用以下命令来切换登录用户： 1su -l name 按照提示输入密码即可。 退出当前用户和退出终端一样，可以使用exit命令或者使用快捷键Ctrl D。 用户组在Linux里面每个用户都有一个归属（用户组）,用户组简单地理解为就是组用户的集合，共享一些资源和权限，同时拥有私有资源。 使用groups命令 1groups name 冒号之前表示用户，后面表示该用户所属的用户组。默认情况下载sudo用户组里的可以使用sudo命令获得root权限，用户也可以使用sudo命令，可以查看/etc/sudoers.d/用户名文件，在/etc/sudoers.d目录下创建了这个文件，从而给用户赋予了sudo权限。 查看/etc/group文件 1cat /etc/group | sort cat命令用户读取指定文件的内容并打印到终端输出。| sort表示将读取的文本进行一个字典排序再输出。 不仅如此，还可以使用grep命令过滤掉一些不想看到的内容。 1cat /etc/group | grep -E 'content' /etc/group文件格式说明 该格式的内容包括用户组(group)、用户组口令、GID(组ID)以及该用户组所包含的用户user，每个用户组一条记录。格式如下： group_name:password:GID:user_list 讲其他用户加入到sudo用户组 默认情况下创建的用户时不具有root权限的，也不再sudo用户组，可以让其加入到sudo用户组从而获取权限： 12su -l namesudo ls 此操作后会提示name不在sudoers文件中，意思就是name不在sudo用户组中，使用usermod命令可以为用户添加用户组，但使用该命令需要有root权限。 可以通过sudo passwd shiyanlou进行设置，操作如下： 123groups namesudo usermod -G sudo namegroups name 这个时候用户name就可以使用sudo获取root权限。 删除用户和用户组删除用户较为简单， 1sudo deluser name --remove-home 使用--remove-home参数在删除用户时会一并将该用户的工作目录一并删除。如果不使用则系统会自动在/home目录为该用户保留工作目录。 123sudo deluser namecat /etc/group | grep 'name'ls /home 删除用户组可以使用groupdel，命令，若群里包含某些用户，则先删除这些用户后才能删除群组。 文件权限所谓文件权限就是文件的访问控制权限，即那些用户和群组可以访问文件以及可以执行什么样的操作。 Linux系统是一个典型的多用户系统，不同的用户处于不同的状态，也就有不同的访问权限。 查看文件权限 ls命令可以列出并显示当前目录下的文件，使用较长格式列出文件： 1ls -l 注：Linux里面一切皆文件。 设备文件（/dev目录下有各种设备文件），socket网络套接字，pipe是管道，软连接文件：链接文件分为两类，另一类是硬链接，软连接类似于windows的快捷方式。 文件权限 读权限，使用cat &lt;file name&gt;命令用来读取某个文件的内容；写权限，表示可以对某个文件进行编辑和修改；执行权限，指可以运行的二进制或者脚本文件，如同windows的exe后缀的文件，一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件。 文件大小 以inode结点大小为单位来表示文件的大小，可以给ls加上-lh参数来直观的查看文件大小。 ls -lh ls -a(all) 12345ls -lhls -a(all)ls -al 查看某一个目录的完整属性，而不是显示目录里面的文件属性ls -dl &lt;目录名&gt;ls -asSh 其中s为显示文件大小，S为按文件大小排序 变更文件所有者切换到name用户，然后在/home/name目录新建一个文件，并命名为iPhone13 12345678su - namepwdtouch iphone13ls -ah iphone13cd /home/namels iphone13sudo chown shiyanlou iphone13 修改文件权限文件的有两种： 方式一：二进制数字表示 每个文件有三组固定的权限，分别对应拥有者，所属用户组，其他用户。文件的读写执行对应字母rwx，以二进制表示就是111，用十进制表示就是7，权限表示为rwx-rwx-rwx-。 修改权限操作： 12chmod 600 filenamels -alh filename 方式二：加减赋值操作 1chmod go-rw filename g、o、u分别表示group（用户组）、others（其他用户）和user（用户），+、-分别表示增加和去掉相应的权限。 更多adduser和useradd的区别是什么 useradd只创建用户，不会创建用户密码和工作目录，创建玩了需要使用passwd &lt;username&gt;去设置新用户和密码。 adduser在创建用户的同时，会创建工作目录和密码（提示设置）。","categories":[{"name":"Linux学习笔记","slug":"Linux学习笔记","permalink":"https://albert-5.github.io/blogs/categories/Linux学习笔记/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://albert-5.github.io/blogs/tags/学习笔记/"},{"name":"Linux","slug":"Linux","permalink":"https://albert-5.github.io/blogs/tags/Linux/"}]},{"title":"Linux笔记","slug":"Linux笔记","date":"2022-01-17T10:29:21.000Z","updated":"2022-02-07T03:26:42.912Z","comments":true,"path":"e511c25d/","link":"","permalink":"https://albert-5.github.io/blogs/e511c25d/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"2021年个人总结","slug":"2021年个人总结","date":"2021-12-31T13:26:30.000Z","updated":"2022-01-17T10:22:50.157Z","comments":true,"path":"491cb1e0/","link":"","permalink":"https://albert-5.github.io/blogs/491cb1e0/","excerpt":"","text":"2021年，过的很快感觉什么都没有发生，又感觉不知发生了什么。一些重要的事情还是有必要留恋一下的。谈起2020年不算是友好的一年去年还觉得“2020”是“爱你爱你”没想到最后成了“二你二你”，生活也是爱开玩笑，明明白白二了我一回当然也可能是因为自己不争气。研究生初试成绩不理想，复试也多次碰壁；毕业呢也并没有感受到快乐，那一句句“年后见”、“兄弟们九月份见”再也没有了，连每晚的“两岸猿叫”都没了；毕业也好，也不好。幸运的是还有书读，还有学上，也来到了之前想来的城市甚至还能在一志愿的学校学习，这该死的缘分。在这里也认识一群新的伙伴，对我也照顾挺多的，我很幸运每一段路上遇到的每个人。不过我现在还有些许迷茫，但我从未放弃自己追逐的目标和方向。总的来说，2021虽有不舍和遗憾但我相信2022仍未来可期，努力有收获，所求有所得！","categories":[{"name":"年度总结","slug":"年度总结","permalink":"https://albert-5.github.io/blogs/categories/年度总结/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://albert-5.github.io/blogs/tags/总结/"},{"name":"2021","slug":"2021","permalink":"https://albert-5.github.io/blogs/tags/2021/"}]},{"title":"贪婪算法","slug":"贪婪算法","date":"2021-11-06T08:19:16.000Z","updated":"2021-11-06T11:13:40.694Z","comments":true,"path":"443f7531/","link":"","permalink":"https://albert-5.github.io/blogs/443f7531/","excerpt":"","text":"贪心算法贪心算法（又称为贪婪算法 Greedy Algorithm）指的是，在对问题求解时，总是做出在当前看来是最好的选择，换句话说，就是通过一步步寻找局部最优解的方式来寻找全局最优解。贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解决定全局最优解。也就是说问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。 找零问题假设商店老板需要找零n元钱，钱币的面额有100元，50元，20元，5元，1元，如何找零使得所需钱币的数量最少？（并没有面额10的钱币）如果是找零276元呢？$1002+501+102+51+1*1=276$代码如下：1234567891011# t表示商店有的零钱面额t = [100, 50, 20, 5, 1]# n表示n元钱def change(t, n): m = [0 for i in range(len(t))] for j, money in enumerate(t): m[j] = n // money # 除法向下取整 n = n % money # 取余 return m, nprint(change(t, 276)) 背包问题常见的背包问题有整数背包和部分背包问题。一个小偷在某个商店发现有$n$个商品，第$i$个商品价值$V_i$元，重$W_i$千克。他希望拿走的东西价值最高，但是他的背包的容量是有限的，最多只能容纳$W$千克的东西，那么他应该拿走那些东西?0-1背包：对于一个商品，小偷要么完整拿走，要么一点不拿，即不能拿走其中一部分，或把一个东西拿走多次。分数背包：对于一个商品，小偷可以拿走其中的一部分。很明显，贪心算法对于分数背包问题肯定能得到最优解，首先计算每个物品的单位重量的价值，然后将它们按照降序排列，接着开始拿取物资即可，只要装得下全部的该类商品那么就可以完全装进去；如果不能全部装下就直到背包装满为止。对于这种问题，0-1背包问题肯定装不满，但不排除偶然可以的情况，并不适用于所有的整数背包问题。代码实现：12345678910111213141516171819202122# 每个商品用元组表示（价值，重量）goods = [(60, 10), (100, 20), (120, 30)]goods.sort(key=lambda x: x[0]/x[1], reverse=True)# w表示背包容量def fractional_backpack(goods, w): # m表示拿走的商品数量 total_v = 0 m = [0 for _ in range(len(goods))] for i, (prize, weight) in enumerate(goods): if w &gt;= weight: m[i] = 1 total_v += prize w -= weight else: m[i] = w/weight total_v += m[i] * prize w = 0 break return m, total_vres1, res2 = fractional_backpack(goods, 50)print(res1, res2) 输出结果如下：12==================== RESTART: C:/Users/DELL/Desktop/test.py ====================[1, 1, 0.6666666666666666] 240.0 拼接最大数字问题有$n$个非负数，将其按照字符串拼接的方式拼接成一个整数。如何可以使得拼接得到的整数最大？例如：32，94, 128，1286， 6， 71可以拼接得到的最大整数位9471321286128但字符串比较数字大小和整数比较数字大小的方式不一样，字符串比较大小就是首先看第一位，大的就大，可是一个字符长而另一个短如何比较就成了问题。思路如下：123456789101112&gt;&gt;&gt; a = '96'&gt;&gt;&gt; b = '97'&gt;&gt;&gt; a+b if a&gt;b else b+a'9796'&gt;&gt;&gt; a = '128'&gt;&gt;&gt; b ='1286'&gt;&gt;&gt; a+b'1281286'&gt;&gt;&gt; b+a'1286128'&gt;&gt;&gt; a+b if a+b &gt; b+a else b+a'1286128' 数字拼接代码如下：123456789101112131415161718from functools import cmp_to_keyli = [30, 94, 128, 1286, 8, 71]def xy_cmp(x, y): # 其中1表示x&gt;y if x+y &lt; y+x: return 1 elif x+y &gt; y+x: return -1 else: return 0def number_join(li): li = list(map(str, li)) li.sort(key=cmp_to_key(xy_cmp)) return \"\".join(li), liprint(number_join(li)) 输出结果如下：12==================== RESTART: C:/Users/DELL/Desktop/test.py ====================94871301286128 扩充：cmp_to_key函数该函数作用是比较12345def lagestnumber(self, nums): from functools import cmp_to_key temp = list(map(str, nums)) temp.sort(key=cmp_to_key(lambda x, y: int(x+y) - int(y+x)), reverse=True) return \"\".join(temp if temp[0] != '0' else '0') 上面这个函数有传入两个参数x,y，当x&gt;y时返回1，等于0时返回0，否则的话返回-1,。它在list的工作原理就是将列表中的元素去两两比较，当cmp返回的是正数时交换两元素。","categories":[{"name":"算法","slug":"算法","permalink":"https://albert-5.github.io/blogs/categories/算法/"}],"tags":[{"name":"python","slug":"python","permalink":"https://albert-5.github.io/blogs/tags/python/"},{"name":"贪婪算法","slug":"贪婪算法","permalink":"https://albert-5.github.io/blogs/tags/贪婪算法/"}]},{"title":"立体视觉计算视差图","slug":"立体视觉计算视差图","date":"2021-10-23T07:59:34.000Z","updated":"2021-10-23T13:25:03.708Z","comments":true,"path":"18650a07/","link":"","permalink":"https://albert-5.github.io/blogs/18650a07/","excerpt":"","text":"立体视觉计算视差图 stereo vision一、实验原理1、立体图像立体视差也就是立体视像，是基于双眼视差所获得的深度知觉。所谓立体图像，其实就是有两台水平的相机对同一场景进行观测，这时，得到的两幅图像就有了相同的图像平面，图像的行是对齐的。参考图如下所示： 原理图1.jpg 由于采用的图像是官网提供的图片，是已经矫正过的，所以这两幅图就可以看成是理想的。根据偏移可以计算出深度，公式如下：$$Z=\\frac{fb}{x_l-x_r}$$其中，$f$是焦距，$b$是两个相机中心的距离，$x_l$和$x_r$分别是左右两个图像中的$x$坐标，分开照相机中心的距离成为基线。 2、计算视差在立体重建算法中，对图像中的每个像素尝试不同的偏移，并按照局部图像周围归一化的互相关值，选择具有最好分数的偏移，记录该最佳偏移。 3、归一化互相关NCC归一化互相关算法原理为：对于已经矫正过的两个图像$I_1$和$I_2$，ncc算法对图像$I_1$一个待匹配像素构建一个匹配窗口，在另一个图像的极线上对每个像素构建匹配窗口与待匹配像素匹配窗口计算相关性，相关性越高则表示匹配度越好。 下面对每个像素周围的像素块来计算归一化相关值，公式如下：$$ncc(I_1,I_2)=\\frac{\\Sigma_x(I_1(X)-\\mu_1)(I_2(X)-\\mu_2)}{\\sqrt{\\Sigma_x(I_1(X)-\\mu_1)^2}\\sqrt{\\Sigma_x(I_2(X)-\\mu_2)^2}}$$ 二、实验步骤得到计算视差图的基本步骤如下： 校正：校正的目的是为了使得两帧图像的光心处于同一水平线上，便于后续的ncc操作。 特征匹配：利用ncc做匹配，右视图中与左视图待测像素同一水平线上相关性最高即为最优匹配，完成匹配后，需要记录视差d，即待测像素水平方向$x_l$和匹配像素水平方向$x_r$之间的差值，再由上述推导的深度公式计算出深度$Z$，最终可以得到一个与原始图像尺寸相同的视差图。 由于不用窗口值会影响得到的视差图的效果，因此在不同窗口下对图像视差图进行求取，以此得到多个视差图。 三、实验代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485from scipy.ndimage import filtersimport stereofrom PIL import Imagefrom scipy import miscfrom scipy.ndimage import filtersfrom pylab import *import numpy as npimport matplotlib.pyplot as plt# 定义归一化ncc方法def plane_sweep_ncc(iml, imr, start, steps, wid): # 使用归一化的互相关计算视差图像 (m, n) = iml.shape print(iml.shape) meanl = zeros((m, n)) meanr = zeros((m, n)) # meanl = zeros_like(iml) # meanr = zeros_like(imr) s = np.zeros((m, n)) s_l = np.zeros((m, n)) s_r = np.zeros((m, n)) # 保存深度平面的数据 deepmaps = np.zeros((m, n, steps)) # 计算图像的平均值 filters.uniform_filter(iml, wid, meanl) filters.uniform_filter(imr, wid, meanr) # 图像归一化处理 norml = iml - meanl normr = imr - meanr # 计算不同视差 for disp in range(steps): # 将左边图像加到右边的图像上 filters.uniform_filter(np.roll(norml, -disp - start) * normr, wid, s) filters.uniform_filter(np.roll(norml, -disp - start) * np.roll(norml, -disp - start), wid, s_l) # 和反归一化 filters.uniform_filter(normr * normr, wid, s_r) # 保存ncc的值 deepmaps[:, :, disp] = s / sqrt(s_l * s_r) # 为每个像素选取最佳深度 return argmax(deepmaps, axis=2)# 高斯滤波器def plane_sweep_guess(iml, imr, start, steps, wid): # 使用高斯的互相关计算视差图像 (m, n) = iml.shape# print(iml.shape) meanl = zeros((m, n)) meanr = zeros((m, n)) # meanl = zeros_like(iml) # meanr = zeros_like(imr) s = np.zeros((m, n)) s_l = np.zeros((m, n)) s_r = np.zeros((m, n)) # 保存深度平面的数据 deepmaps = np.zeros((m, n, steps)) # 计算图像的平均值 filters.gaussian_filter(iml, wid, 0, meanl) filters.gaussian_filter(imr, wid, 0, meanr) # 图像归一化处理 norml = iml - meanl normr = imr - meanr # 计算不同视差 for disp in range(steps): # 将左边图像加到右边的图像上 filters.gaussian_filter(np.roll(norml, -disp - start) * normr, wid, 0, s) filters.gaussian_filter(np.roll(norml, -disp - start) * np.roll(norml, -disp - start), wid, 0, s_l) # 和反归一化 filters.gaussian_filter(normr * normr, wid, 0, s_r) # 保存ncc的值 deepmaps[:, :, disp] = s / sqrt(s_l * s_r) # 为每个像素选取最佳深度 return argmax(deepmaps, axis=2)iml = np.array(Image.open('../input/stereo-sample/im0.png').convert('L'), 'f')imr = np.array(Image.open('../input/stereo-sample/im1.png').convert('L'), 'f')# 开始偏移并设置步长steps = 50start = 4# ncc的宽度wid = 30for i in range(1, wid): # ncc方法 # res_ncc = plane_sweep_ncc(iml, imr, start, steps, i) # 高斯方法 print('宽度&#123;&#125;时的滤波结果！'.format(i)) res_gaussian = plane_sweep_guess(iml, imr, start, steps, i) # imsave(r'.vscode\\prml-myself\\vision_ncc_out\\&#123;&#125;.jpg'.format(i), res_ncc) imsave(r'./&#123;&#125;.jpg'.format(i), res_gaussian) 四、实验展示原始图像如下： im0.jpg im1.jpg 对不同窗口下的视差图如下（窗口值从1-30,50，100） 窗口width ncc方法 gaussian 1 1.jpg](https://i.loli.net/2021/10/23/1pf6BJWuRZSnLTV.jpg) | ![1.jpg 5 5.jpg](https://i.loli.net/2021/10/23/PglouKOMWNjGkDp.jpg) | ![5.jpg 30 29.jpg](https://i.loli.net/2021/10/23/GpSYfN156xAe23u.jpg) | ![29.jpg 50 50.jpg](https://i.loli.net/2021/10/23/eKY8JXnmjfy1aEw.jpg) | ![50.jpg 100 100.jpg](https://i.loli.net/2021/10/23/j9kLR4YpTyPvmMJ.jpg) | ![100.jpg 五、实验结果分析结果上来看，窗口值的大小改变对结果较大，wid值越小，颗粒感越大，匹配结果的区分度越低，并且成散粉分裂状；随着窗口值增大，匹配区分度逐渐清晰，精度也变高；当窗口值过大时，效果没有更好，反而暗区会越来越黑，匹配效果不是很好。","categories":[{"name":"计算机视觉","slug":"计算机视觉","permalink":"https://albert-5.github.io/blogs/categories/计算机视觉/"}],"tags":[{"name":"立体视觉","slug":"立体视觉","permalink":"https://albert-5.github.io/blogs/tags/立体视觉/"},{"name":"视差图","slug":"视差图","permalink":"https://albert-5.github.io/blogs/tags/视差图/"}]},{"title":"深度优先和广度优先搜索算法","slug":"深度优先和广度优先搜索算法","date":"2021-10-21T14:57:13.000Z","updated":"2021-10-23T12:17:05.491Z","comments":true,"path":"70de7154/","link":"","permalink":"https://albert-5.github.io/blogs/70de7154/","excerpt":"","text":"参考学习内容","categories":[{"name":"排序算法","slug":"排序算法","permalink":"https://albert-5.github.io/blogs/categories/排序算法/"}],"tags":[{"name":"深度优先搜索算法","slug":"深度优先搜索算法","permalink":"https://albert-5.github.io/blogs/tags/深度优先搜索算法/"},{"name":"广度优先搜索算法","slug":"广度优先搜索算法","permalink":"https://albert-5.github.io/blogs/tags/广度优先搜索算法/"}]},{"title":"排序算法之快速排序","slug":"排序算法之快速排序","date":"2021-10-18T07:27:47.000Z","updated":"2021-11-06T08:56:36.008Z","comments":true,"path":"77638675/","link":"","permalink":"https://albert-5.github.io/blogs/77638675/","excerpt":"","text":"快速排序–一种使用D&amp;C的排序算法算法原理 快速排序是对冒泡排序算法的改进，基本思想是：选择一基准元素，以此将剩余元素中的小于该基准元素的值放在左边，大于该基准元素的值放在右边；然后再在左侧序列和右侧序列做同样的处理操作；以此类推，直至各个序列都剩余一个元素时，即排序完成。 算法实现步骤 首先设定一基准值（pivot），通过该基准值将待排序序列分成左右两部分。 将小于或等于基准值的元素放在序列左边，将大于基准值的元素放在序列的右边。此时左边序列的元素都是小于基准值的，右边的元素都是大于基准值的，这个基准值就叫做分区(partition)操作。 此时，左边和右边的序列均可看作是新的序列，分别对左边、右边的序列进行基准值的选择，将序列再次分成两部分，同样的，左边部分的元素值小于基准值，右边部分的元素值大于基准值。 重复上述操作，通过递归-recurive将左侧部分排好序后，在递归对右边进行排序，当左右两个部分个数据排序完成后，整个序列再次组合加起来就形成了一个有序的序列了。代码实现123456789101112def quicksort(array): if len(array) &lt; 2: return array else: pivot = array[0] less = [i for i in array[1:] if i &lt;= pivot] greater = [i for i in array[1:] if i &gt; pivot] return quicksort(less) + [pivot] + quicksort(greater)print(quicksort([1, 5, 2, 12, 34, 9])) 关于复杂度快速排序算法的性能高度依赖于基准值的选取。在上述代码中是将第一个元素作为基准值，且要处理的数据是有序的。它并不会检查数据的有序性，只会按部就班的进行排序操作。最糟糕情况下，所有的元素都是已经排好序的，但此时算法仍会按照步骤进行排序，且选择的基准值是第一个元素，所花费的时间较长，复杂度为O(n²)；最好的情况是已排好序的序列，每次选取序列的中间位置元素作为基准值，这样复杂度大大减小，为O(nlogn)。 快速排序算法动图展示 🚩推荐阅读（由hexo文章推荐插件驱动）LDA线性判别分析排序算法之选择排序豆瓣电影top250zen of pythonPython学习笔记——可变对象和不可变对象","categories":[{"name":"排序算法","slug":"排序算法","permalink":"https://albert-5.github.io/blogs/categories/排序算法/"}],"tags":[{"name":"python","slug":"python","permalink":"https://albert-5.github.io/blogs/tags/python/"},{"name":"快速排序","slug":"快速排序","permalink":"https://albert-5.github.io/blogs/tags/快速排序/"}]},{"title":"LDA线性判别分析","slug":"LDA线性判别分析","date":"2021-10-16T13:13:38.000Z","updated":"2021-10-17T08:13:56.801Z","comments":true,"path":"2f6ec745/","link":"","permalink":"https://albert-5.github.io/blogs/2f6ec745/","excerpt":"","text":"LDA线性判别分析基本概念线性分类： 指存在一个线性方程可以把待分类样本分离开，或者用一个超平面将正负样本分开，表达式为$$y=w^\\mathrm T+b$$所谓超平面即是区分样本点的一个决策面，在二维世界中，可以理解为一条直线，如一次函数。非线性分类： 指不存在一个线性分类能将样本分隔开，可以是一个曲面，也可以是多个超平面的组合。 LDA思想核心思想：类内小，类间大线性判别分析（Linear Discrimination Analysis, LDA）是一种监督学习的线性降维方法，即每个样本都是由类别的输出。其主要思想是”投影后类内方差最小，类间方差最大“，我们知道，对于一组数据来说，均值决定了它的中心，方差则是决定了这组数据的离散程度，越大越离散，越小越集中。在二分类问题中，我们将样本点在低纬度上进行投影，投影后希望每一种类别数据的投影点尽可能的接近，两种类别的数据点的中心尽可能的远离。 LDA算法的推导以及优化LDA原理，投影到低纬度上的空间中，使得投影后的点会形成按类别区分一簇一簇的分布情况，相同类别的点较为集中，不用类别的点相聚较远。 lda.png 那什么是线性判别分析呢？所谓线性判别分析，就是将样本数据点投影到直线上，直线函数的解析式又称为线性函数，通常的表达式为：$$y=w^\\mathrm T$$其中$w$表示特征向量，$x$表示样本列向量，$y$表示投影后的样本列向量。首先对两类样本进行考虑分析，然后在推广到多维问题。给定数据集$D=^m_{i=1},y∈(0,1)$，$X_i,\\mu_i,\\Sigma_i$分别表示$i\\in{0, 1}$类示例的集合、均值向量、协方差矩阵。若将数据投影到直线$w$上，则两类样本的中心在直线上的投影分别为$ w^\\mathrm T\\mu_0$和 $ w^\\mathrm T \\mu_1$；若将所以样本点都投影到之想爱你上，则两类样本的协方差矩阵分别为$w^\\mathrm T\\Sigma_0w$和$w^\\mathrm T\\Sigma_1w$。想要使得同类样本的投影带你尽可能地接近，可以让同类样本点的投影点的协方差尽可能的小，即$w^\\mathrm T\\Sigma_0w$+$w^\\mathrm T\\Sigma_1w$尽可能小；而若想要异类样本的投影点尽可能的远离，可以让类中心带你的距离尽可能的大，即$||w^\\mathrm T\\mu_0-w^\\mathrm T\\mu_1||$尽可能大，同时考虑即可得到待优化的目标：$$J=\\frac{||w^\\mathrm T\\mu_0-w^\\mathrm T\\mu_1||}{w^\\mathrm T\\Sigma_0w+w^\\mathrm T\\Sigma_1w}=\\frac{w^\\mathrm T(\\mu_0-\\mu_1)(\\mu_0-\\mu_1)^\\mathrm Tw}{w^\\mathrm T(\\Sigma_0 +\\Sigma_1)w}$$定义类内散度矩阵（within-class scatter matrix）$$\\begin{aligned}S_w&amp;=\\Sigma_0+\\Sigma_1\\&amp;=\\Sigma(x-\\mu_0)(x-\\mu_0)^\\mathrm T+\\Sigma(x-\\mu_1)(x-\\mu_1)^\\mathrm T\\end{aligned}$$以及类间散度矩阵（between-class scatter matrix）$$\\begin{aligned}S_b =(\\mu_0-\\mu_1)(\\mu_0-\\mu_1)^\\mathrm T\\end{aligned}$$所以待优化目标为$$J=\\frac{w^\\mathrm TS_bw}{w^\\mathrm TS_ww}$$这就是LDA欲最大化的目标表达，即$ S_b $和$S_w$的“广义瑞利商”（generalized Rayleigh quotient）.如何求取$w$呢？对于瑞利商来说，分子分母都是关于$w$的二次项，因此其解与$w$的长度无关，只与其方向有关，所以不妨令$w^\\mathrm TS_ww=1$，则有：$$\\begin{aligned}\\underset w min\\quad -w^\\mathrm TS_bw\\s.t. \\quad w^\\mathrm TS_ww =1\\end{aligned}$$由拉格朗日乘子法得到等价式$$S_bw=\\lambda S_ww$$其中，$\\lambda$是拉格朗日乘子。注意到$S_bw$的方向为$(\\mu_0-\\mu_1)$，令$$S_bw=\\lambda (\\mu_0-\\mu_1)$$即可得$$w=S_w^{-1}(\\mu_0-\\mu_1)$$$w$的最大值就是矩阵$S_w^{-1}S_b$的最大特征值。至此，投影面即可得到。 python实现以及结果展示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import numpy as npimport matplotlib.pyplot as plt# 生成两类随机样本def createdata(): points1 = np.mat(np.random.random((10, 2))*2+4) points2 = np.mat(np.random.random((10, 2))*3+2) return points1, points2# 计算样本均值def cal_mean(samples, num): ave = [] a, b = np.shape(samples[num]) for i in range(b): n = np.sum(samples[num][:, i]) / a ave.append(n) return np.array(ave)# 计算类内离散度和类间离散度def cal_swb(samples): # 获取样本的行列值 a, b = np.shape(samples[0]) # 获取样本 points1, points2 = samples[0:2] # 调用求均值函数 pointsmean1 = np.mat(cal_mean(points1, 0)) pointsmean2 = np.mat(cal_mean(points2, 1)) allpointsmean1 = (pointsmean1 + pointsmean2)/2 # 先计算第一类类内离散矩阵 s1 = 0 for i in range(a): s1 = s1 + (points1[i, :] - pointsmean1).T * (points1[i, :] - pointsmean1) s2 = 0 for i in range(a): s2 = s2 + (points2[i, :] - pointsmean2).T * (points2[i, :] - pointsmean2) sw = (a*s1 + a*s2)/(a + a) # 计算类间离散矩阵 sb = (pointsmean1 - pointsmean2).T*(pointsmean1 - pointsmean2) return np.mat(sw), np.mat(sb), np.mat(allpointsmean1)samples = createdata()plt.plot(samples[0][:, 0], samples[0][:, 1], 'b.')plt.plot(samples[1][:, 0], samples[1][:, 1], 'r.')\"\"\" 测试 \"\"\"print(samples[0].shape)pointsmean1 = cal_mean(samples, 0)pointsmean2 = cal_mean(samples, 1)print(pointsmean1)print(pointsmean2)sw, sb, allmean = cal_swb(samples)# print(sw.shape)# print(sb.shape)# print(np.linalg.inv(sw))# 求最大特征值对应的特征向量eigvalue, eigvector = np.linalg.eig(np.linalg.inv(sw).dot(sb))print(eigvalue)indexvec = np.argsort(-eigvalue)nlargestindex = indexvec[1]print(nlargestindex)# 最佳投影方向求得w = np.array(eigvector[nlargestindex])# print(w)# print(w[0][0])# print(w.shape)# 绘制散点图plt.figure()plt.scatter(np.array(samples[0][:, 0]), np.array(samples[0][:, 1]), c='b', marker='o')plt.scatter(np.array(samples[1][:, 0]), np.array(samples[1][:, 1]), c='r', marker='*')x = np.linspace(0, 10, num=50)y = w[0][1]/w[0][0]*xx1 = np.array((samples[0][:, 0] + samples[0][:, 1]*(w[0][1]/w[0][0]))/(1+(w[0][1]/w[0][0])**2))x2 = np.array((samples[1][:, 0] + samples[1][:, 1]*(w[0][1]/w[0][0]))/(1+(w[0][1]/w[0][0])**2))y1 = w[0][1]/w[0][0]*x1y2 = w[0][1]/w[0][0]*x2plt.scatter(x1, np.array(y1), c='c', marker='o')plt.scatter(x2, np.array(y2), c='m', marker='*')plt.plot(x, y, color='r')plt.show() 结果展示如下 课堂小作业2（2）.png 🚩推荐阅读（由hexo文章推荐插件驱动）排序算法之快速排序排序算法之选择排序豆瓣电影top250zen of pythonPython学习笔记——可变对象和不可变对象","categories":[{"name":"机器学习算法","slug":"机器学习算法","permalink":"https://albert-5.github.io/blogs/categories/机器学习算法/"}],"tags":[{"name":"LDA线性判别分析","slug":"LDA线性判别分析","permalink":"https://albert-5.github.io/blogs/tags/LDA线性判别分析/"},{"name":"python","slug":"python","permalink":"https://albert-5.github.io/blogs/tags/python/"}]},{"title":"排序算法之选择排序","slug":"排序算法之选择排序","date":"2021-10-16T13:11:16.000Z","updated":"2021-10-16T13:23:41.374Z","comments":true,"path":"cb33e42c/","link":"","permalink":"https://albert-5.github.io/blogs/cb33e42c/","excerpt":"","text":"排序算法之选择排序数组数据在内存中的顺序是连续的，在使用时需要向计算机申请分配一定的内存空间，如果申请的空间一定，再加入新的数据时如果当前空间不足需要重新向计算机申请；同样，如果先前申请了大量的空间，但在使用过程中并没有被用到，则会造成空间的浪费。 术语数组的元素带编号，编号从0开始，这个位置叫做索引，故说：”元素a位于索引1处“，在元素读取和插入时有以下特征： 数组和链表操作.png 由于索引的存在，所以数组在读取数据时就有很快的速度；但在插入数据方面，需要将待插入位置的后面的所有数据向后移位，时间较长。 链表链表中的元素可存储在内存的任何地方，其中的每个元素存放的都是下一个元素的地址，这样就能使一系列的内存地址串在一起。删除操作时，链表是更好的选择，只需要修改前一个元素指向的地址。 选择排序 算法思想：首先在未排序的队列中选择最小或者最大的元素，并存放到新队列的起始位置；然后再从剩余的元素中选择最小或者最大的一个，再将其放入到新队列的后面，以此重复操作。 乐队歌曲作品如下： 选择排序1.png 对列表中的歌曲按照播放次数降序排列，进而将自己喜欢的音乐进行排序。方法即是遍历列表，找出播放次数最多的音乐，然后将其添加到新列表里。 选择排序2.png 再次进行此操作，找出第二多的乐队。 选择排序3.png 继续这样做，进而得到一个新的有序列表。 选择排序4.png 时间复杂度上来看，对于列表里的n个元素，需要对每个元素都进行查看，所以时间复杂度为O（n)。 12345678910111213141516171819def findsmallest(arr): smallest = arr[0] smallest_index = 0 for i in range(len(arr)): if arr[i] &lt; smallest: smallest = arr[i] smallest_index = i return smallest_indexdef selectsort(arr): newarr = [] for i in range(len(arr)): smallest = findsmallest(arr) newarr.append(arr.pop(smallest)) return newarrprint(selectsort([3, 7, 2, 1, 9, 6])) 输出结果如下： 1[1, 2, 3, 6, 7, 9] 🚩推荐阅读（由hexo文章推荐插件驱动）排序算法之快速排序LDA线性判别分析豆瓣电影top250zen of pythonPython学习笔记——可变对象和不可变对象","categories":[{"name":"排序算法","slug":"排序算法","permalink":"https://albert-5.github.io/blogs/categories/排序算法/"}],"tags":[{"name":"python","slug":"python","permalink":"https://albert-5.github.io/blogs/tags/python/"},{"name":"选择排序","slug":"选择排序","permalink":"https://albert-5.github.io/blogs/tags/选择排序/"}]},{"title":"Camera-calibration","slug":"Camera-calibration","date":"2021-10-09T07:20:19.000Z","updated":"2021-11-06T08:22:24.375Z","comments":true,"path":"4b5e616e/","link":"","permalink":"https://albert-5.github.io/blogs/4b5e616e/","excerpt":"","text":"相机标定一、前提准备1、伪硬件 名称 数量 标定板8×10 1 手机 1 待标定照片 12 支架 1 手机固定在支架上，调整标定板位置，对其从不同角度进行拍照，所拍摄照片为11张。保存到文件夹后对其进行依次命名：*.jpg(如：1.jpg) 2、软件&nbsp; 使用的编程语言：python&nbsp; 工具包：opencv, numpy, glob 二、寻找标定棋盘并进行标定1、python + opencv 的方案 &nbsp;&nbsp;利用opencv寻找棋盘，所用到的函数如下： &nbsp;cv2.TERM_CRITERIA_MAX_ITER | cv2.TERM_CRITERIA_EPS：设置寻找亚像素点的终止迭代规则，前者为在指定迭代次数后停止算法，后者为要求的精度，在相机标定时才用的最大迭代次数为30次，最大精度为0.001。 &nbsp;images = glob.glob(r&#39;G:\\biaoding\\*.jpg&#39;)：glob函数能够返回所有匹配到的文件路径列表，用来读取待标定的棋盘图像。 &nbsp; cv2.findChessboardCorners：该函数用来找到棋盘，其返回值为角点，且会按一定顺序排列。 &nbsp; cv2.cornerSubPix：在上述找到角点的前提下寻找亚像素点，目的是为了增强检测角点的精度。 &nbsp; cv2.drawChessboardCorners：绘制找到的角点 &nbsp; retv, mtx, dist, rvecs, tvecs = cv2.calibrateCamera：相机标定函数，经过以上的计算以及找角点后进行相机标定，返回值为相机矩阵，畸变系数，旋转以及变换向量。 2、具体实施123456789101112131415161718192021222324252627282930313233343536373839404142import cv2import globimport numpy as np# 采用循环找取亚像素点的参数，最大迭代次数采用30次，精度为0.001，两者同时满足时停止迭代criteria = (cv2.TERM_CRITERIA_MAX_ITER | cv2.TERM_CRITERIA_EPS, 30, 0.001)# 所采用的棋盘规格8×10objp = np.zeros((7 * 9, 3), np.float32)objp[:, :2] = np.mgrid[0:9, 0:7].T.reshape(-1, 2) # 将世界坐标系建在标定板上，所有点的Z坐标全部为0obj_points = [] # 坐标系中的三维点img_points = [] # 图像平面中的二维点# 从文件中依次读取照片images = glob.glob(r'G:\\biaoding\\*.jpg')for fname in images: img = cv2.imread(fname) cv2.namedWindow('img', 0) cv2.resizeWindow('img', 600, 600) cv2.imshow('img',img) cv2.waitKey() # cv2.destroyAllWindows() gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) size = gray.shape[::-1] # print(size) # findchessboardcorner函数里寻找棋盘图的内角点 retv, corners = cv2.findChessboardCorners(gray, (7, 9), None) print(retv) if retv: obj_points.append(objp) # 在原角点的基础上寻找亚像素角点 corners2 = cv2.cornerSubPix(gray, corners, (6, 6), (-1, -1), criteria) print(corners2) if [corners2]: img_points.append(corners2) else: img_points.append(corners) # 绘制找到的角点 cv2.drawChessboardCorners(img, (7, 9), corners, retv) cv2.namedWindow('img', 0) cv2.resizeWindow('img', 600, 600) cv2.imshow('img', img) cv2.waitKey(20000) &nbsp; 待标定图像如下所示： 找到棋牌并进行标定后的图片如下图所示： 标定前 标定后 3、相机相关参数相机矩阵Mtx： 123[[1.86761254e+04 0.00000000e+00 4.09207342e+02][0.00000000e+00 1.77781655e+03 4.23180100e+02][0.00000000e+00 0.00000000e+00 1.00000000e+00]] 畸变系数dist: 12dist: [[-0.05541607 -0.17312714 0.0776916 -0.0767596 0.07245637]] 外参旋转向量: 123[[ 2.10761526], [-0.5901612 ], [-2.10187724]] 外参平移向量: 123[[ 1.32373017], [16.72137644], [57.99935184]] 🚩推荐阅读（由hexo文章推荐插件驱动）关于opencv的配置问题","categories":[{"name":"计算机视觉","slug":"计算机视觉","permalink":"https://albert-5.github.io/blogs/categories/计算机视觉/"}],"tags":[{"name":"相机标定","slug":"相机标定","permalink":"https://albert-5.github.io/blogs/tags/相机标定/"},{"name":"计算机视觉","slug":"计算机视觉","permalink":"https://albert-5.github.io/blogs/tags/计算机视觉/"}]},{"title":"c语言短路求值","slug":"c语言短路求值","date":"2021-09-23T15:31:29.000Z","updated":"2021-10-17T08:14:36.358Z","comments":true,"path":"78ff7d86/","link":"","permalink":"https://albert-5.github.io/blogs/78ff7d86/","excerpt":"","text":"C语言学习过程遇到的重点内容记录 何为短路求值？所谓短路求值，其实就是C语言逻辑操作符&amp;&amp;和||的特性，具体特性如下： &amp;&amp; 逻辑与&amp;&amp; 逻辑操作符的左操作数总是首先进行求值, 如果它的值为真, 则继续计算右操作数的值, 然后执行与操作得到表达式结果; 如果它的值为假, 根据与操作 有假则假 的性质可以断定该表达式的值为假, 所以不再计算右操作数的值。 || 逻辑或|| 逻辑操作符的左操作数也是首先进行求值, 如果它的值为假, 则继续计算右操作数的值, 然后执行与操作得到表达式结果; 如果它的值为真, 根据或操作 有真则真 的性质可以断定该表达式的值为真, 所以不再计算右操作数的值。 实际操作体验1234567891011# include &lt;stdio.h&gt;// 短路求值int main()&#123; int a = 0, b = 1; (a = 0) &amp;&amp; (b = 2); printf(\"a = %d, b = %d\\n\", a, b); (a = 1) || (b = 2); printf(\"a = %d, b = %d\\n\", a, b); return 0;&#125; 上诉代码为简单的逻辑运算程序，我们大概会这样想，输出结果为a = 0, b = 2，a = 1, b = 2，但实际上并不是这样，具体输出如下所示： 12345[Running] cd \"e:\\code2\\.vscode\\\" &amp;&amp; gcc test.c -o test &amp;&amp; \"e:\\code2\\.vscode\\\"testa = 0, b = 1a = 1, b = 1[Done] exited with code=0 in 0.657 seconds 为什么呢？ 这就是因为这两个逻辑操作符的特性问题，在(a = 0) &amp;&amp; (b = 2);中，由于a = 0，在逻辑与&amp;&amp;逻辑运算时为0，此时后面的程序不会再执行，也就是还是原来的值b = 1。 在(a = 1) || (b = 2);中，a的值是非零的，所以判断为1，此时后面的程序就不会在执行，这时的b的值为原来给定的值，即为b = 1。 🚩推荐阅读（由hexo文章推荐插件驱动）Git学习笔记","categories":[{"name":"C语言","slug":"C语言","permalink":"https://albert-5.github.io/blogs/categories/C语言/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://albert-5.github.io/blogs/tags/学习笔记/"},{"name":"短路求值","slug":"短路求值","permalink":"https://albert-5.github.io/blogs/tags/短路求值/"},{"name":"C语言","slug":"C语言","permalink":"https://albert-5.github.io/blogs/tags/C语言/"}]},{"title":"关于opencv的配置问题","slug":"关于opencv的配置问题","date":"2021-09-22T12:51:13.000Z","updated":"2021-09-22T14:16:19.965Z","comments":true,"path":"3ffaec4c/","link":"","permalink":"https://albert-5.github.io/blogs/3ffaec4c/","excerpt":"","text":"最近学习了计算机视觉的课程，准备用opencv来实现相机标定，但在import cv2时出现了一些问题，看了许多博客都没感觉有啥用。 问题一：vscode中import cv2出现错误在进行调用库文件import cv2时出现提示：ImportError: No module named cv2这种情况是属于没有下载opencv文件或者是安装位置不对导致的，所以去网站下了相关文件，具体链接如下：opencv点击下载 opencv.jpg 注：下载前确定好自己的python版本，版本不对的话还是会出现错误的。 紧接着，ctrl + r输入cmd，在命令提示窗内继续输入pip install &lt;刚刚下载下来的文件路径&gt; 问题二：pip install出现问题上诉操作之后按道理来说是没有任何问题的，但偏偏还是出现了问题：1ImportError: DLL load failed：找不到指定模块 这种情况错误产生的原因是对应模块的文件不完善或者没有对应的模块； 解决方法下载相对应的模块，点击进入。因为我用的是opencv-python，所以在下载完成后将python文件夹下的python38版本的opencv文件（.pyd结尾的）复制到python的安装目录\\python38\\Lib\\site-packages下,并将其改名为c2.pyd。 查找python安装路径的方法 win + r输入cmd进入命令提示窗： cmd.jpg 然后，输入python进入到python交互环境，再输入以下命令： 12import syssys.path 这样就能看到相对应的site-packages文件夹。 问题三：Defaulting to user installation because normal site-packages is not writeable错误提示 从网上看了很多帖子，方法也都实验过了但都无济于事，先对一些方法做一些集锦： 使用user权限pip install --user &lt;package name&gt; 更改文件夹权限，让packages有权限写入； 找对python文件夹，确保将其加入到环境变量中，环境变量的查看以及操作方法如下：在桌面右键此电脑，点击属性，选择高级系统设置,编辑并下列python文件夹加入到path，...\\python38\\Scripts\\、...\\python38\\、...\\python38\\Lib。 注：我的问题在第二步将.pyd文件添加到site-packages下就解决了。 结果 测试结果.jpg 显示的图太大了，不太好展示。 完结！ 🚩推荐阅读（由hexo文章推荐插件驱动）Camera-calibration","categories":[{"name":"计算机视觉","slug":"计算机视觉","permalink":"https://albert-5.github.io/blogs/categories/计算机视觉/"}],"tags":[{"name":"计算机视觉","slug":"计算机视觉","permalink":"https://albert-5.github.io/blogs/tags/计算机视觉/"},{"name":"opencv","slug":"opencv","permalink":"https://albert-5.github.io/blogs/tags/opencv/"}]},{"title":"Git学习笔记","slug":"Git学习笔记","date":"2021-09-20T17:19:39.000Z","updated":"2021-10-17T08:14:24.302Z","comments":true,"path":"a91eaa72/","link":"","permalink":"https://albert-5.github.io/blogs/a91eaa72/","excerpt":"","text":"本地提交到远程的步骤以及命令首先新建一个文件test.txt,在Git bash中键入命令12345git add test.txtgit commit -m &apos;add a new file test.txt&apos;git push origin maingit pull orgin main 在GitHub中就能看到提交的文件以及相关记录了。 🚩推荐阅读（由hexo文章推荐插件驱动）c语言短路求值","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://albert-5.github.io/blogs/categories/学习笔记/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://albert-5.github.io/blogs/tags/Git/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://albert-5.github.io/blogs/tags/学习笔记/"},{"name":"分布式系统","slug":"分布式系统","permalink":"https://albert-5.github.io/blogs/tags/分布式系统/"}]},{"title":"Hexo文章置顶","slug":"Hexo文章置顶","date":"2021-09-19T08:28:21.000Z","updated":"2021-09-19T08:42:12.531Z","comments":true,"path":"315dc9f6/","link":"","permalink":"https://albert-5.github.io/blogs/315dc9f6/","excerpt":"","text":"文章默认是按照时间的顺序逆序排列的，即新发布的会出现在前面，但考虑到有些文章的需要置顶显示，所以想增加文章置顶功能。 对node_modules/hexo-generator-index/lib/generator.js进行修改需要添加的代码为：12345678910111213posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; if(a.top == b.top) return b.date - a.date; else return b.top - a.top; &#125; else if(a.top &amp;&amp; !b.top) &#123; return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; &#125;); 添加后的完整generator.js文件内容为：12345678910111213141516171819202122232425262728293031323334'use strict';var pagination = require('hexo-pagination');module.exports = function(locals) &#123; var config = this.config; var posts = locals.posts.sort(config.index_generator.order_by); posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; if(a.top == b.top) return b.date - a.date; else return b.top - a.top; &#125; else if(a.top &amp;&amp; !b.top) &#123; return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; &#125;); var paginationDir = config.pagination_dir || 'page'; var path = config.index_generator.path || ''; return pagination(path, posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 设置好上述内容后就可以在需要置顶的文章上添加top属性了，值越大越靠前：123456789---title: Hexo文章置顶category: - 个人博客tags: - 文章置顶top: 0date: 2021-09-19 16:28:21---","categories":[{"name":"个人博客","slug":"个人博客","permalink":"https://albert-5.github.io/blogs/categories/个人博客/"}],"tags":[{"name":"文章置顶","slug":"文章置顶","permalink":"https://albert-5.github.io/blogs/tags/文章置顶/"}]},{"title":"Github-charts展示","slug":"Github-charts展示","date":"2021-09-19T08:12:19.000Z","updated":"2021-10-17T08:14:51.131Z","comments":true,"path":"3fd1c6f0/","link":"","permalink":"https://albert-5.github.io/blogs/3fd1c6f0/","excerpt":"","text":"本文主要介绍如何在个人博客中展示Github Chart。且在Github上已经有了开源工具，并提供了API，稍微配置下就行了。 工具地址：Github Chart API 这个工具可以实时地将Github Chart信息转化为一张图片，如下图所示，我们可以将其插入到我们的博客中。 使用方法我们只需要在 https://ghchart.rshah.org/ 这个地址上加上自己的Github用户名即可构造自己的Github Chart图片的链接了，比如我的Github名为albert-5，那就是 https://ghchart.rshah.org/albert-5 Markdown 插入图片1![albert-5’s Github Charts](https://ghchart.rshah.org/albert-5) HTML插入图片1&lt;img src=\"http://ghchart.rshah.org/albert-5\" alt=\"albert-5's Github Charts\" /&gt; 自定义颜色此工具还支持自定义配色方案，我们可以提供任何基本颜色来为图标添加阴影，自定义颜色可以访问网站。 我们只需要访问http://ghchart.rshah.org/&lt;##&gt;/albert-5，将##替换为我们想要设置的十六进制颜色代码（去掉颜色代码前面的#）就行了。 1&lt;img src=\"http://ghchart.rshah.org/009006/albert-5\" alt=\"Albert's Blue Github Chart\" /&gt; 参考文档 Github Chart API","categories":[{"name":"Github","slug":"Github","permalink":"https://albert-5.github.io/blogs/categories/Github/"}],"tags":[{"name":"Github-charts","slug":"Github-charts","permalink":"https://albert-5.github.io/blogs/tags/Github-charts/"}]},{"title":"豆瓣电影top250","slug":"豆瓣电影top250","date":"2021-09-16T16:04:19.000Z","updated":"2021-09-16T16:11:05.670Z","comments":true,"path":"573d89ae/","link":"","permalink":"https://albert-5.github.io/blogs/573d89ae/","excerpt":"","text":"豆瓣电影Top 250原理方法使用的模块chardet模块—判断编码 1Pip install chardet 使用上述命令安装模块 123456789101112131415#如果你的python没有安装chardet模块，你需要首先安装一下chardet判断编码的模块哦import chardetimport urllib#先获取网页内容data = urllib.urlopen('http://www.pythontab.com').read()#用chardet进行内容分析chardit = chardet.detect(data) data1 = urllib.urlopen('http://www.baidu.com').read() chardit1 = chardet.detect(data1) print chardit['encoding'] # pythontab print chardit1['encoding'] # baidu BeautifulSoup库 安装bs4模块 1pip install beautifulsoup4 代码使用 12345from bs4 import BeautifulSoupimport requestsurl = \"\"html = requests.get(url)soup = BeautifulSoup(html, 'html.parser') find_all()方法返回文档中符合条件的所有tags，尽管有时候我们只想得到一个结果。比如文章中只有一个标签，那么使用find_all()方法来查找标签不太合适了使用find_all()方法设置limit=1参数不如直接使用find()方法 12345&gt; soup.find_all('title', limit=1)&gt; # [&lt;title&gt;The Story&lt;/title&gt;]&gt; soup.find('title')&gt; # [&lt;title&gt;The Story&lt;/title&gt;]&gt; 唯一的区别是find_all()方法返回的结果是只包含一个元素的列表，而find()方法直接返回结果；find_all()方法没有找到指定元素时返回空列表，而find()方法找不到目标时返回None 拓展 关于find_all()和find()方法的介绍 find() 1find(name, attrs, recursive, text, **wargs) # recursive 递归的，循环的 这些参数相当于过滤器一样可以进行筛选处理。不同的参数过滤可以应用到以下情况： 查找标签，基于name参数 查找文本，基于text参数 基于正则表达式的查找 查找标签的属性，基于attrs参数 基于函数的查找 通过标签查找： 可以传递任何标签的名字来查找到它第一次出现的地方。找到后，find函数返回一个BeautifulSoup的标签对象。 123456from bs4 import BeautifulSoupwith open('ecologicalpyramid.html', 'r') as ecological_pyramid: soup = BeautifulSoup(ecological_pyramid, 'html')producer_entries = soup.find('ul')print(type(producer_entries)) 输出结果： 通过文本查找： 直接字符串的话，查找的是标签。如果想要查找文本的话，则需要用到text参数。如下所示： 123456from bs4 import BeautifulSoupwith open('ecologicalpyramid.html', 'r') as ecological_pyramid: soup = BeautifulSoup(ecological_pyramid, 'html')producer_string = soup.find(text = 'plants')print(plants_string) 输出：plants 通过正则表达式查找： 想找出第一个邮箱地址，但是第一个邮箱地址没有标签包含，所以通过其他方式很难找到。但是可以将邮箱地址进行正则表达式处理。 1234567891011121314import refrom bs4 import BeautifulSoupemail_id_example = \"\"\"&lt;br/&gt;&lt;div&gt;The below HTML has the information that has email ids.&lt;/div&gt; abc@example.com &lt;div&gt;xyz@example.com&lt;/div&gt; &lt;span&gt;foo@example.com&lt;/span&gt; \"\"\"soup = BeautifulSoup(email_id_example)emailid_regexp = re.compile(\"\\w+@\\w+\\.\\w+\") # regexp 表达式对象first_email_id = soup.find(text=emailid_regexp) print(first_email_id) 输出结果：abc@example.com 通过标签属性进行查找： 上面html代码，其中第一个消费者在ul标签里面且id属性为priaryconsumer（priary consumer一次消费者，初级消费者）。 123456from bs4 import BeautifulSoupwith open('ecologicalpyramid.html', 'r') as ecological_pyramid: soup = BeautifulSoup(eccological_pyramid, 'html')primary_consumer = soup.find(id='primaryconsumers')print(primary_consumer.li.div.string) 输出结果：deer 基于定制属性查找： 通过标签属性查找的方式适用大多数标签属性，包括id，style，title，但有 “-”，Class标签属性例外。 比如html5标签中的data-custom属性，如果我们这样 12345customattr = \"\"\"&lt;p data-custom='custom'&gt;custo attributeexample&lt;/p&gt;\"\"\"customsoup = BeautifulSoup(customattr, 'lxml')customSoup.find(data-custom=\"custom\") 那么则会报错。原因是在python中变量不能含有”-“这个字符，而我们传递的data-custom有这个字符。 解决办法是在attrs属性用字典进行传递参数。 12using_attrs = customsoup.find(attrs=&#123;'data-custom':'custom'&#125;)print(using_attrs) 基于css类的查找： class是python的保留关键字，所以无法使用class这个关键字。 第一种方法：在attrs属性用字典进行传递参数 12css_class = soup.find(attrs=&#123;'class':'primaryconsumers'&#125;)print(css_class) 第二种方法：BeautifulSoup中的特别关键字参数class_。 1css_class = soup.find(class_ = 'primaryconsumers') 基于定义的函数进行查找： 可以传递函数到find()来基于函数定义的条件查找。函数必须返回True或False。 1234def is_secondary_consumers(tag): return tag.has_attr('id') and tag.get('id') == 'secondaryconsumers'secondary_consumer = soup.find(is_secondary_consumers)print(secondary_consumer.li.div.string) 输出：fox 将方法进行组合后进行查找： 可以用其中任何方法进行组合进行查找，比如同时基于标签名和id号。 find_all()函数 1find_all(name, attrs, recursive, text, limit, **kwargs) limit参数可以限制得到的结果的数目。 参照前面的邮件地址例子，得到所有邮件地址： 12email_ids = soup.find_all(text=emailid_regexp)print(email_ids) 输出结果：[u&#39;abc@example.com‘,u&#39;xyz@example.com‘,u&#39;foo@example.com‘] 使用limit参数： 12email_ids_limited = soup.find_all(text=emailid_regexp, limit = 2)print(email_ids_limited) 限制得到两个结果，所以输出结果：[u&#39;abc@example.com‘,u&#39;xyz@example.com‘] 可以向find函数传递True或False参数，如果传递True给find_all()，则返回soup对象的所有标签。对于find()来说，则返回soup对象的第一个标签。 12all_texts = soup.find_all(text=True)print(all_texts) 同样，可以在传递text参数时传递一个字符串列表，那么find_all()会找到挨个在列表中定义过的字符串。 12all_texts_in_list = soup.find_all(text=['plants', 'algae'])print(all_texts_in_list) 输出结果： 1[u'plants', u'alage'] 这个同样适用于查找标签，标签属性，定制属性和CSS类。如： 1div_li_tags = soup.find_all(['div', 'li']) 并且find()和find_all()都会查找一个对象所有后辈们，不过可以通过recursive参数控制。(recursive回归，递归) 如果recursive=False，只会找到该对象的最近后代。 通过标签之间的关系进行查找 查找父标签 通过find_parents()或find_parent()。它们之间的不同类似于find()和find_all()的区别。 find_parents()返回全部的相匹配的父标签，而find_parent()返回最近一个父标签。适用于find()的方法同样适用于这两个方法。 在第一消费者例子中，可以找到离Primaryconsumer最近的ul父标签。 1234primaryconsumers = soup.find_all(class_ = 'primaryconsumerlist')primaryconsumer = primaryconsumers[0]parent_ul = primaryconsumer.find_parents('ul')print(parent_ul) 一个简单的找到一个标签的父标签的方法是使用find_parent()却不带任何参数。 1immediateprimary_consumer_parent = primary_consumer.find_parent() 查找同胞 标签在同一个等级，这些标签是同胞关系，比如参照上面金子塔例子，所有的ul标签就是同胞的关系。上面的ul标签下的producers，primaryconsumers，， secondaryconsumers，teriaryconsumers就是同胞关系。 div下的plants和algae不是同胞关系，但是plants和临近的number是同胞关系。 Beautiful Soup自带查找同胞的方法。 比如find_next_siblings()和find_next_sibling()查找对象下面的同胞。(sibling兄弟姐妹) 123producers = soup.find(id = 'producers')next_siblings = producers.find_next_siblings()print(next_siblings) 输出结果将会输出与之临近的下面的所有同胞html代码。 查找下一个 对每一个标签来说，下一个元素可能会是定位字符串，标签对象或者其他BeautifulSoup对象，我们定义下一个元素为当前元素最靠近的元素 。 这不用于同胞定义，我们有方法可以找到我们想要标签的下一个其他元素对象。find_all_next()找到与当前元素最靠近的所有对象。而find_next()找到离当前元素最接近的对象。 比如，找到在第一个div标签后的所有li标签 12first_div = soup.divall_li_tags = first_div.find_all_next('li') 查找上一个 与查找下一个相反的是查找前一个，用find_previous()和find_all_previous()。 slwt的使用代理IP的爬取 【参考文章】 https://my.oschina.net/u/3914536/blog/1860929 🚩推荐阅读（由hexo文章推荐插件驱动）排序算法之快速排序LDA线性判别分析排序算法之选择排序zen of pythonPython学习笔记——可变对象和不可变对象","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://albert-5.github.io/blogs/categories/爬虫/"}],"tags":[{"name":"python","slug":"python","permalink":"https://albert-5.github.io/blogs/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://albert-5.github.io/blogs/tags/爬虫/"}]},{"title":"博客搭建及相关问题","slug":"博客搭建及相关问题","date":"2021-09-16T15:38:35.000Z","updated":"2021-09-16T15:39:27.523Z","comments":true,"path":"69864530/","link":"","permalink":"https://albert-5.github.io/blogs/69864530/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"个人博客之点击效果","slug":"个人博客之点击效果","date":"2021-09-16T04:46:50.000Z","updated":"2021-10-17T08:15:03.870Z","comments":true,"path":"beffc16d/","link":"","permalink":"https://albert-5.github.io/blogs/beffc16d/","excerpt":"","text":"前提声明：个人博客文件目录blogs 新建love.js文件在blogs/themes/indigo/source/js目录下新建love.js文件，复制一下代码。1234567891011121314151617181920212223242526272829303132333435363738394041424344!function (e, t, a) &#123; function r() &#123; for (var e = 0; e &lt; s.length; e++) s[e].alpha &lt;= 0 ? (t.body.removeChild(s[e].el), s.splice(e, 1)) : (s[e].y--, s[e].scale += .004, s[e].alpha -= .013, s[e].el.style.cssText = \"left:\" + s[e].x + \"px;top:\" + s[e].y + \"px;opacity:\" + s[e].alpha + \";transform:scale(\" + s[e].scale + \",\" + s[e].scale + \") rotate(45deg);background:\" + s[e].color + \";z-index:99999\"); requestAnimationFrame(r) &#125; function n() &#123; var t = \"function\" == typeof e.onclick &amp;&amp; e.onclick; e.onclick = function (e) &#123; t &amp;&amp; t(), o(e) &#125; &#125; function o(e) &#123; var a = t.createElement(\"div\"); a.className = \"heart\", s.push(&#123; el: a, x: e.clientX - 5, y: e.clientY - 5, scale: 1, alpha: 1, color: c() &#125;), t.body.appendChild(a) &#125; function i(e) &#123; var a = t.createElement(\"style\"); a.type = \"text/css\"; try &#123; a.appendChild(t.createTextNode(e)) &#125; catch (t) &#123; a.styleSheet.cssText = e &#125; t.getElementsByTagName(\"head\")[0].appendChild(a) &#125; function c() &#123; return \"rgb(\" + ~~(255 * Math.random()) + \",\" + ~~(255 * Math.random()) + \",\" + ~~(255 * Math.random()) + \")\" &#125; var s = []; e.requestAnimationFrame = e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) &#123; setTimeout(e, 1e3 / 60) &#125;, i(\".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;\"), n(), r() &#125;(window, document); 注：可先新建txt文本，然后将后缀改为.js。 在主页面中插入js文件打开文件blogs/themes/indigo/layout/layout.ejs，插入以下代码：1&lt;script type=\"text/javascript\" src=\"/js/love.js\"&gt;&lt;/script&gt; 注：src为love.js文件的路径，且将行代码插入到标签里。 另一种方便的方法，就是直接插入在线js12//引入小心心特效&lt;script src=\"https://cdn.jsdelivr.net/gh/Sanarous/files@1.151/js/clicklove.js\"&gt;&lt;/script&gt; 重新生成文件并deploy123hexo cleanhexo ghexo d","categories":[{"name":"个人博客","slug":"个人博客","permalink":"https://albert-5.github.io/blogs/categories/个人博客/"}],"tags":[{"name":"爱心点击效果","slug":"爱心点击效果","permalink":"https://albert-5.github.io/blogs/tags/爱心点击效果/"}]},{"title":"python之文件读取","slug":"python之文件读取","date":"2021-09-15T15:15:02.000Z","updated":"2021-10-17T08:14:14.075Z","comments":true,"path":"21c7d502/","link":"","permalink":"https://albert-5.github.io/blogs/21c7d502/","excerpt":"","text":"读写文件两种路径的介绍绝对路径：总是从根文件夹开始相对路径：相对程序的当前工作目录 文件读取 读取步骤：&nbsp;1、调用open()函数，返回一个File对象&nbsp;2、调用File对象的read()和write()方法。&nbsp;3、调用File对象的close()函数，关闭文件。 open()函数打开文件 在使用open()函数打开文件时，需要向函数中传递一个字符串路径，可以是相对路径，也可以是绝对路径。但open()函数返回的是一个File对象。 1files = open('E:\\\\hello.txt') 此方法默认是以读模式打开文件的，也就是python只让从文件中读取文本而不能以其他方式修改它。 读取文件内容上面介绍了关于打开文件的方法，就是使用open()函数，但是要读取文件里的内容就要使用File对象的read()方法。 1234files = open('E:\\\\hello.txt')hello_content = files.read()print(type(hello_content))print(hello_content) 输出内容 12345678[Running] python -u \"e:\\vscode_py\\.vscode\\hello.py\"&lt;class 'str'&gt;nihao welcome to my worldnice to meet youi all alone beweep my outcast state.[Done] exited with code=0 in 0.144 seconds 很明显，我们看到此时读取的内容为字符串。另一种读取方法是readlines()，它从文件中取得一个字符串的列表，此时列表中的每一个字符串就是文本中的一行，两者对比如下。 1234files = open('E:\\\\hello.txt')hello_content = files.readlines()print(type(hello_content))print(hello_content) 读取结果如下： 12345[Running] python -u \"e:\\vscode_py\\.vscode\\hello.py\"&lt;class 'list'&gt;['nihao \\n', 'welcome to my world\\n', 'nice to meet you\\n', 'i all alone beweep my outcast state.'][Done] exited with code=0 in 0.138 seconds 此时，返回的对象类型为list（列表），字符串列表。 写文件 以读模式打开文件，则不能进行修改（写）等操作；此时需要用写模式或添加文本模式来打开文件，但写模式将会覆盖原有的内容，从头开始，将w作为第二个参数传给open()；添加模式是在原文件的末尾添加内容，将a作为第二个参数传递给open()，以添加模式打开文件。 1234files = open('E:\\\\hello.txt','a')hello_content = files.write('\\nThis is text that you input\\n')# print(type(hello_content))print(hello_content) 然后在读取文件 123files = open('E:\\\\hello.txt')hello_content = files.read()print(hello_content) 输出结果如下： 12345678910[Running] python -u \"e:\\vscode_py\\.vscode\\hello.py\"nihao welcome to my worldnice to meet youi all alone beweep my outcast state.This is text that you input[Done] exited with code=0 in 0.131 seconds 用shelve模块保存变量 用该模块能够将代码中的变量保存到二进制的shelf文件中。 1import shelveshelfFile = shelve.open('mydata')cats = ['dog', 'pig', 'Simon']shelfFile['dog'] = catsshelfFile.close() 运行后会生成mydata.bak、mydata.dat、mydata.dir等文件。 屏幕截图 2021-09-15 230115.jpg 与正常文本操作方式不同，不用考虑是读模式还是写模式。 1234import shelveshelfFile = shelve.open('mydata')print(type(shelfFile))print(shelfFile['dog']) 输出结果为 12345[Running] python -u \"e:\\vscode_py\\.vscode\\hello.py\"&lt;class 'shelve.DbfilenameShelf'&gt;['dog', 'pig', 'Simon'][Done] exited with code=0 in 0.151 seconds 🚩推荐阅读（由hexo文章推荐插件驱动）排序算法之快速排序LDA线性判别分析排序算法之选择排序zen of pythonPython学习笔记——可变对象和不可变对象","categories":[{"name":"python编程","slug":"python编程","permalink":"https://albert-5.github.io/blogs/categories/python编程/"}],"tags":[{"name":"python","slug":"python","permalink":"https://albert-5.github.io/blogs/tags/python/"},{"name":"文件读写","slug":"文件读写","permalink":"https://albert-5.github.io/blogs/tags/文件读写/"}]},{"title":"wechat信息抓取","slug":"wechat信息抓取","date":"2019-09-16T16:08:03.000Z","updated":"2021-09-16T16:11:05.667Z","comments":true,"path":"6739178/","link":"","permalink":"https://albert-5.github.io/blogs/6739178/","excerpt":"","text":"微信好友 一览无余【itchat】一个微信的开源API，微信是一种常用的社交网络应用程序。 通过python中的聊天访问个人微信账户，然后通过微信机器人进行处理个人所有基本信息。 安装itchat模块1pip install itchat 简单使用123import itchatitchat.auto_login()itchat.send('Hello, filehelper', toUserName='filehelper') 详情见itchat官方网站 主要用到的方法有： itchat.login()微信扫码登录 itchat.get_friends()返回完整的列表好友，每个好友为一个字典，其中第一项为自己的账号基本信息，带入参数update=True，将更新好友列表并返回，具体使用itchat.get_friends(update=True) 技巧：使用itchat.login()进行登录微信会有一个问题，就是每运行一次就会生成一个二维码，叮··· 扫描登录，是不是过于麻烦了？ 直接采用itchat.auto_login()，在一定时间内，可以不用扫码登录，只需要在手机移动端确定登录就行了，毕竟是在模拟网页登录 开始操作12345678# 导入所需要的库import itchatimport csvimport pandas as pd# 启用热键扫码登录微信itchat.auto_login(hotReload=True)# 抓取好友信息friends = itchat.get_friends(update=True)[0:] 这时，好友信息已经在存储在friends里面了。 定义函数抓取个字段信息get_var(var) 1234567891011121314151617def get_var(var): variable = [] for i in friends: value = i[var] variable.append(value) return variable# 调用函数得到各个变量,存在csv文件中NickName = get_var('NickName')Sex = get_var('Sex')Province = get_var('Province')City = get_var('City')Signature = get_var('Signature')Username = get_var('UserName')ContactFlag = get_var('ContactFlag')SnsFlag = get_var('SnsFlag') 定义函数parse_friends()，将得到的好友数据存储在txt文本中 1234567891011121314# 收集并保存好友信息数据def parse_friends(): # 设置需要爬取的信息字段,使用字典形式,参考官网以及个人需求设置字段信息 result = &#123;'NickName': NickName, 'Sex': Sex, 'Province': Province, 'City': City, 'UserName': Username, 'ContactFlag': ContactFlag, 'SnsFlag': SnsFlag, 'Signature': Signature, &#125; for user in friends: with open('myfriends.txt', 'a', encoding='utf8') as fh: fh.write('-------------------------\\n') for r in result: with open('myfriends.txt', 'a', encoding='utf8') as fh: fh.write(str(r) + \":\" + str(user.get(r))+\"\\n\") print(\"分析完毕！\") 设置最后打印标识，提醒已完成信息存储；同时当前文件夹中出现一个文件myfriends.txt 信息文件 定义函数male_female()统计男女以及其他人数和比例 统计 然后利用pandas模块将文件信息保存在csv文件中 12345678data = &#123;'NickName': NickName, 'Sex': Sex, 'Province': Province, 'City': City, 'UserName': Username, 'ContactFlag': ContactFlag, 'SnsFlag':SnsFlag, 'Signature':Signature, &#125;frame = DataFrame(data)frame.to_csv('data2.csv', index=True, encoding='utf-8')with open('data2.csv', 'r', encoding='utf-8') as myfile: reader = csv.reader(myfile) for row in reader: print(row) 便于后续采用pandas中的 value_counts 进行计数可视化处理 简单可视化操作 采用pyecharts中的Pie绘制饼图 12# 导入模块from pyecharts.charts import Pie 123456configure(output_image=True)pie = Pie(\"性别比例\", background_color='white', title_text_size=25)attr = ['male', 'female', 'other']v1 = [57.14, 27.04, 15.82] # 好友男女百分比pie.add('', attr, v1, is_label_show=True)pie.render() # render渲染，默认在当前文件夹中的render.html 再使用pyecharts时，可能会出现一些错误，比如不存在Pie或者无法导入Pie等 看了一些博客之后，我采用的方法是降级，即降低库的版本，可能是与python版本有冲突 效果 比例.png 或许这就是你Single的原因吧 –苦笑– 🚩推荐阅读（由hexo文章推荐插件驱动）排序算法之快速排序LDA线性判别分析排序算法之选择排序zen of pythonPython学习笔记——可变对象和不可变对象","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://albert-5.github.io/blogs/categories/爬虫/"}],"tags":[{"name":"python","slug":"python","permalink":"https://albert-5.github.io/blogs/tags/python/"},{"name":"wechat","slug":"wechat","permalink":"https://albert-5.github.io/blogs/tags/wechat/"}]},{"title":"Leetcode","slug":"Leetcode","date":"2019-05-16T11:14:23.000Z","updated":"2021-11-07T11:48:31.790Z","comments":true,"path":"c0a45ceb/","link":"","permalink":"https://albert-5.github.io/blogs/c0a45ceb/","excerpt":"","text":"领扣–引领新时尚 1. 两数之和问题给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解法1–暴力解法 思路： 给定一个数组和一个特定的目标值，对每一个数进行遍历，然后利用两层循环遍历的值进行if条件判断，如果相等，则返回下标；否则返回None. 具体实现：123456789101112class Solution:def twoSum(self, nums,target): for i in range(len(nums)): for j in range(i+1, len(nums)): if nums[i]+nums[j] == target: return [i, j] else: continuenums = [2,7,11,15]target = 9solution = Solution()print(solution.twoSum(nums,target)) 缺点：过于暴力，两层循环使得时间代价过高。 时间复杂度：O(n^2^) 解法2–较优化算法 思路： 相比于暴力解法，此法优化了双层循环 一次循环遍历，然后用目标值减去数组中的每一个值，然后判断减去得到的值是否在数组中，进而再判断小标问题； 具体实现： 12345678910111213class Solution:def twoSum(self, nums, target):for i in range(0, len(nums)): a = target - nums[i] if a in nums: b = nums.index(a) if b != i: return [i, b]nums = [2, 7, 11, 15]target = 9solution = Solution()print(solution.twoSum(nums, target)) 解法3–优化算法 &lt;来源于网络，怪自己 :sweat:···&gt; 思路： 优解:创建一个字典，通过循环把 target - nums[x]作为键，x作为值存入字典，边存边检查当前正在处理的nums[x]是否存在于字典中，存在：返回字典中nums[x]的值，和当前正在使用的x的值。 具体实现： 12345678910111213class Solution:def twoSum(self, nums, target):dic = &#123;&#125;for x in range(len(nums)): if target - nums[x] in dic: result = [dic[target - nums[x]], x] return result dic[nums[x]] = xnums = [2, 7, 11, 15]target = 9solution = Solution()print(solution.twoSum(nums, target)) 2. 回文数问题判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121输出: true 示例 2: 输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 解法1–较优化解法 思路： 将所给数字转化为字符串，因为回文数是具有对称性的，所以比较字符串的第一位和最后一位、第一次位和末尾次位 ······但是由于一位数以及负数和末尾为0的数的特殊性，应该加以判断。 由于对称性，所以考虑字符长度，奇偶数：通过模2判断只需要判断一般就可以了。 实现： 123456789101112131415161718192021222324252627282930class Solution(object): def isPalindrome(self, x): n = str(x) print(n) m = len(n) count = 0 if m == 1: return True elif n[0] == \"-\" or n[m-1] == '0': return False elif m % 2 == 0: for i in range(int(m/2)): if n[i] == n[m-1-i]: count += 1 else: return False else: for i in range(int((m+1)/2)): if n[i] == n[m-1-i]: count += 1 else: return False if count == int(m/2) or count == int((m+1)/2): return TrueX = 0solution = Solution()print(solution.isPalindrome(X)) 时间复杂度为 O(n) 执行代码，运行时间108 ms 3. 最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。示例 1： 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2： 输入：nums = [1]输出：1 示例 3： 输入：nums = [0]输出：0 示例 4： 输入：nums = [-1]输出：-1 思路： 给定一个数组，对其进行遍历，用两个变量，其中一个用来存储最大的和，一个用来记录当前的和。代码如下 1234567891011121314class Solution: def maxSubArray(nums): sums = nums[0] maxs = nums[0] for i in range(1, len(nums)): if sums &gt; 0: sums += nums[i] else: sums = nums[i] maxs = sums if sums &gt; maxs else maxs return maxsnums = [-1, 2, -1, 3, -2]print(Solution.maxSubArray(nums)) 4. 只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？示例 1: 输入: [2,2,1]输出: 1 示例 2: 输入: [4,1,2,1,2]输出: 4 思路解法1：位运算使用抑或运算XOR来解答较为简单，对数组的元素进行抑或运算，相同为1，不同为0，即可判断只出现呢一次的数字了。代码实现123456789# 位运算xorfrom functools import reduceclass Solution: def singleNumber(snums): return reduce(lambda x, y: x^y, nums)resfun = Solutionnums = [1, 1, 2, 2, 4, 4, 5]print(resfun.singleNumber(nums)) 解法2：通用解法对于数组中的元素进行次数计算，如果有出现一次的即可返回结果。代码实现123456789class Solution: def singleNumber(nums): for i in nums: c = nums.count(i) if c == 1: return inums = [1, 1, 2, 3, 2]print(Solution.singleNumber(nums)) 注：count函数计算你次数，因为数组中只存在一个出现次数为1的，所以只要返回值为1，即可得到该元素。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://albert-5.github.io/blogs/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://albert-5.github.io/blogs/tags/Leetcode/"}]}],"categories":[{"name":"你好，世界","slug":"你好，世界","permalink":"https://albert-5.github.io/blogs/categories/你好，世界/"},{"name":"Linux学习笔记","slug":"Linux学习笔记","permalink":"https://albert-5.github.io/blogs/categories/Linux学习笔记/"},{"name":"年度总结","slug":"年度总结","permalink":"https://albert-5.github.io/blogs/categories/年度总结/"},{"name":"算法","slug":"算法","permalink":"https://albert-5.github.io/blogs/categories/算法/"},{"name":"计算机视觉","slug":"计算机视觉","permalink":"https://albert-5.github.io/blogs/categories/计算机视觉/"},{"name":"排序算法","slug":"排序算法","permalink":"https://albert-5.github.io/blogs/categories/排序算法/"},{"name":"机器学习算法","slug":"机器学习算法","permalink":"https://albert-5.github.io/blogs/categories/机器学习算法/"},{"name":"C语言","slug":"C语言","permalink":"https://albert-5.github.io/blogs/categories/C语言/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://albert-5.github.io/blogs/categories/学习笔记/"},{"name":"个人博客","slug":"个人博客","permalink":"https://albert-5.github.io/blogs/categories/个人博客/"},{"name":"Github","slug":"Github","permalink":"https://albert-5.github.io/blogs/categories/Github/"},{"name":"爬虫","slug":"爬虫","permalink":"https://albert-5.github.io/blogs/categories/爬虫/"},{"name":"python编程","slug":"python编程","permalink":"https://albert-5.github.io/blogs/categories/python编程/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://albert-5.github.io/blogs/categories/Leetcode/"}],"tags":[{"name":"hello_world","slug":"hello-world","permalink":"https://albert-5.github.io/blogs/tags/hello-world/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://albert-5.github.io/blogs/tags/学习笔记/"},{"name":"Linux","slug":"Linux","permalink":"https://albert-5.github.io/blogs/tags/Linux/"},{"name":"总结","slug":"总结","permalink":"https://albert-5.github.io/blogs/tags/总结/"},{"name":"2021","slug":"2021","permalink":"https://albert-5.github.io/blogs/tags/2021/"},{"name":"python","slug":"python","permalink":"https://albert-5.github.io/blogs/tags/python/"},{"name":"贪婪算法","slug":"贪婪算法","permalink":"https://albert-5.github.io/blogs/tags/贪婪算法/"},{"name":"立体视觉","slug":"立体视觉","permalink":"https://albert-5.github.io/blogs/tags/立体视觉/"},{"name":"视差图","slug":"视差图","permalink":"https://albert-5.github.io/blogs/tags/视差图/"},{"name":"深度优先搜索算法","slug":"深度优先搜索算法","permalink":"https://albert-5.github.io/blogs/tags/深度优先搜索算法/"},{"name":"广度优先搜索算法","slug":"广度优先搜索算法","permalink":"https://albert-5.github.io/blogs/tags/广度优先搜索算法/"},{"name":"快速排序","slug":"快速排序","permalink":"https://albert-5.github.io/blogs/tags/快速排序/"},{"name":"LDA线性判别分析","slug":"LDA线性判别分析","permalink":"https://albert-5.github.io/blogs/tags/LDA线性判别分析/"},{"name":"选择排序","slug":"选择排序","permalink":"https://albert-5.github.io/blogs/tags/选择排序/"},{"name":"相机标定","slug":"相机标定","permalink":"https://albert-5.github.io/blogs/tags/相机标定/"},{"name":"计算机视觉","slug":"计算机视觉","permalink":"https://albert-5.github.io/blogs/tags/计算机视觉/"},{"name":"短路求值","slug":"短路求值","permalink":"https://albert-5.github.io/blogs/tags/短路求值/"},{"name":"C语言","slug":"C语言","permalink":"https://albert-5.github.io/blogs/tags/C语言/"},{"name":"opencv","slug":"opencv","permalink":"https://albert-5.github.io/blogs/tags/opencv/"},{"name":"Git","slug":"Git","permalink":"https://albert-5.github.io/blogs/tags/Git/"},{"name":"分布式系统","slug":"分布式系统","permalink":"https://albert-5.github.io/blogs/tags/分布式系统/"},{"name":"文章置顶","slug":"文章置顶","permalink":"https://albert-5.github.io/blogs/tags/文章置顶/"},{"name":"Github-charts","slug":"Github-charts","permalink":"https://albert-5.github.io/blogs/tags/Github-charts/"},{"name":"爬虫","slug":"爬虫","permalink":"https://albert-5.github.io/blogs/tags/爬虫/"},{"name":"爱心点击效果","slug":"爱心点击效果","permalink":"https://albert-5.github.io/blogs/tags/爱心点击效果/"},{"name":"文件读写","slug":"文件读写","permalink":"https://albert-5.github.io/blogs/tags/文件读写/"},{"name":"wechat","slug":"wechat","permalink":"https://albert-5.github.io/blogs/tags/wechat/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://albert-5.github.io/blogs/tags/Leetcode/"}]}